{"version":3,"sources":["closest-polyfill.js","helpers.js","aria-autocomplete.js"],"names":["Element","prototype","matches","msMatchesSelector","webkitMatchesSelector","closest","s","el","parentElement","parentNode","nodeType","REGEX_TRIM","trimString","theString","replace","addClass","element","classes","currentValue","getAttribute","current","finalValue","i","cs","split","l","length","indexOf","setAttribute","removeClass","REGEX_AMPERSAND","REGEX_DUPE_WHITESPACE","REGEX_MAKE_SAFE","REGEX_TO_IGNORE","cleanString","toLowerCase","isPrintableKey","keyCode","mergeObjects","n","o","p","hasOwnProperty","dispatchEvent","event","document","e","createEvent","initEvent","fireEvent","setElementState","selected","instance","nodeName","checked","elementChangeEventTimer","clearTimeout","setTimeout","processSourceArray","sourceArray","mapping","setCleanedLabel","toReturn","mapValue","mapLabel","result","entry","value","label","toString","cleanedLabel","push","expose","appIndex","DEFAULT_OPTIONS","source","sourceMapping","delay","minLength","maxResults","showAllButton","confirmOnBlur","multiple","maxItems","multipleSeparator","placeholder","noResultsText","listClassName","inputClassName","wrapperClassName","cssNameSpace","asyncQueryParam","asyncMaxResultsParam","srDeleteText","srDeletedText","srSelectedText","srExplanatoryText","srAssistiveText","srResultsText","onAsyncSuccess","undefined","onResponse","onSearch","onSelect","onReady","onClose","onOpen","AriaAutocomplete","options","ariaAutocomplete","elementIsInput","elementIsSelect","ids","ELEMENT","id","PREFIX","LIST","INPUT","BUTTON","OPTION","WRAPPER","OPTION_SELECTED","SR_ASSISTANCE","SR_ANNOUNCEMENTS","list","input","wrapper","showAll","srAnnouncements","xhr","term","async","menuOpen","disabled","filtering","forceShowAll","filteredSource","currentListHtml","currentSelectedIndex","filterTimer","announcementTimer","componentBlurTimer","init","name","args","apply","toRemove","removeAttribute","expanded","show","triggerOptionCallback","hide","query","prop","text","textContent","exists","describedBy","cssName","nodes","childNodes","index","resetOptionAttributes","target","focus","setOptionFocus","toFocus","toAdd","valToSet","valToSetString","join","disable","enable","focusAfterSelection","option","alreadySelected","setSourceElementValues","buildMultiSelected","announce","results","resultsLoop","j","k","labelMatch","thisResult","toShow","optionId","updated","removeSelectedFromResults","callback","noText","optionClass","cancelFilterPrep","newListHtml","innerHTML","canCancel","XMLHttpRequest","encode","encodeURIComponent","isShowAll","limit","limitParam","queryParam","params","url","test","abort","open","onload","responseText","items","setListOptions","send","callbackResponse","handleAsync","call","search","staticSourceIndex","nameSpace","doValueOverrideCheck","runNow","setInputDescription","modifier","type","altKey","ctrlKey","metaKey","equalVals","filter","preventDefault","filterPrep","force","activeElem","activeElement","contains","isQueryIn","isQueryContainedIn","bind","toUse","handleOptionSelect","filterPrepShowAll","targetIsInput","handleEnterKey","selectedLength","lastSelectedLabel","announcement","pop","focusInput","handleComponentBlur","handleUpArrowKey","handleDownArrowKey","handleKeyDownDefault","addEventListener","prepKeyDown","nodeIndex","elements","querySelectorAll","checkbox","toPush","querySelector","separator","valueArr","val","indexInSource","Array","isArray","prepListSourceArray","prepListSourceDdl","prepListSourceCheckboxes","ariaAutocompleteOriginalFor","labelledBy","explainerText","listClass","inputClass","wrapperClass","explainer","newHtml","insertAdjacentHTML","destroy","removeChild","setHtml","getElementById","prepListSource","setInputStartingStates","bindEvents","elem","autocomplete","api","window"],"mappings":"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","file":"aria-autocomplete.min.js","sourceRoot":"../src","sourcesContent":["if (!Element.prototype.matches) {\n    Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n}\nif (!Element.prototype.closest) {\n    Element.prototype.closest = function (s) {\n        var el = this;\n        do { \n            if (el.matches(s)) { \n                return el; \n            } \n            el = el.parentElement || el.parentNode; \n        } while (el !== null && el.nodeType === 1);\n        return null;\n    };\n}","const REGEX_TRIM = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n/**\n * trim string helper\n * @param {string} theString\n */\nexport function trimString(theString) {\n    return theString == null ? '' : (theString + '').replace(REGEX_TRIM, '');\n}\n\n/**\n * add class(es) to element\n * @param {Element} element - element to add class(es) to\n * @param {String} classes - space delimitted class(es) to add\n */\nexport function addClass(element, classes) {\n    let currentValue = trimString(\n        element.getAttribute && element.getAttribute('class')\n    );\n    let current = ' ' + currentValue + ' ';\n    let finalValue = '';\n\n    for (let i = 0, cs = classes.split(' '), l = cs.length; i < l; i += 1) {\n        if (cs[i] !== '' && current.indexOf(' ' + cs[i] + ' ') === -1) {\n            finalValue += ' ' + cs[i];\n        }\n    }\n    if (currentValue !== (finalValue = trimString(currentValue + finalValue))) {\n        element.setAttribute('class', finalValue);\n    }\n}\n\n/**\n * remove class(es) from element\n * @param {Element} element - element to add class(es) to\n * @param {String} classes - space delimitted class(es) to remove\n */\nexport function removeClass(element, classes) {\n    let currentValue = trimString(\n        element.getAttribute && element.getAttribute('class')\n    );\n    let finalValue = ' ' + currentValue + ' ';\n\n    for (let i = 0, cs = classes.split(' '), l = cs.length; i < l; i += 1) {\n        finalValue = finalValue.replace(' ' + cs[i] + ' ', ' ');\n    }\n    if (currentValue !== (finalValue = trimString(finalValue))) {\n        element.setAttribute('class', finalValue);\n    }\n}\n\n// regex constants used for string cleaning\nconst REGEX_AMPERSAND = /&/g;\nconst REGEX_DUPE_WHITESPACE = /\\s\\s+/g;\nconst REGEX_MAKE_SAFE = /[.*+?^${}()|[\\]\\\\]/g;\nconst REGEX_TO_IGNORE = /[\\u2018\\u2019',:\\u2013-]/g;\n/**\n * @description clean string of some characters, and make safe for regex searching\n * @param {String} theString\n * @returns {String}\n */\nexport function cleanString(theString) {\n    theString = theString.replace(REGEX_TO_IGNORE, ''); // ignore quotes, commas, colons, and hyphens\n    theString = theString.replace(REGEX_AMPERSAND, 'and'); // treat & and 'and' as the same\n    theString = theString.replace(REGEX_MAKE_SAFE, '\\\\$&'); // make safe for regex searching\n    theString = theString.replace(REGEX_DUPE_WHITESPACE, ' '); // ignore duplicate whitespace\n    return trimString(theString.toLowerCase()); // case insensitive\n}\n\n/**\n * @description check if keycode is for a printable/width-affecting character\n * @param {Number} keyCode\n * @returns {Boolean}\n */\nexport function isPrintableKey(keyCode) {\n    return (\n        (keyCode >= 48 && keyCode <= 57) || // 0-9\n        (keyCode >= 65 && keyCode <= 90) || // a-z\n        (keyCode >= 96 && keyCode <= 111) || // numpad 0-9, numeric operators\n        (keyCode >= 186 && keyCode <= 222) || // semicolon, equal, comma, dash, etc.\n        keyCode === 32 || // space\n        keyCode === 8 || // backspace\n        keyCode === 46 // delete\n    );\n}\n\n/**\n * @description merge objects together to generate a new one\n * @param {Object} args - objects to merge together\n * @returns {Object}\n */\nexport function mergeObjects(...args) {\n    let n = {};\n    for (let i = 0, l = args.length; i < l; i += 1) {\n        let o = args[i];\n        for (let p in o) {\n            if (o.hasOwnProperty(p) && typeof o[p] !== 'undefined') {\n                n[p] = o[p];\n            }\n        }\n    }\n    return n;\n}\n\n/**\n * @description dispatch event helper\n * @param {Element} element\n * @param {String} event\n */\nexport function dispatchEvent(element, event) {\n    if ('createEvent' in document) {\n        let e = document.createEvent('HTMLEvents');\n        e.initEvent(event, true, true);\n        element.dispatchEvent(e);\n    } else {\n        element.fireEvent('on' + event);\n    }\n}\n\n/**\n * @description set element option or checkbox to specified state and trigger change event\n * @param {Element} element\n * @param {Boolean} selected\n * @param {(AriaAutocomplete|Object)} instance\n */\nexport function setElementState(element, selected, instance) {\n    selected = !!selected;\n    if (element) {\n        // handle checkbox\n        if (\n            element.nodeName === 'INPUT' &&\n            typeof element.checked === 'boolean' &&\n            element.checked !== selected\n        ) {\n            element.checked = selected;\n            dispatchEvent(element, 'change');\n        }\n\n        // handle dropdown option\n        if (element.nodeName === 'OPTION' && element.selected !== selected) {\n            element.selected = selected;\n            // ensure change event only fires once for dropdown\n            if (instance.elementChangeEventTimer) {\n                clearTimeout(instance.elementChangeEventTimer);\n            }\n            instance.elementChangeEventTimer = setTimeout(function() {\n                dispatchEvent(element.closest('select'), 'change');\n            }, 1);\n        }\n    }\n}\n\n/**\n * @description process an array of strings or objects to ensure needed props exist\n * @param {(String|Object)[]} sourceArray\n * @param {Object=} mapping - value and label mapping used in object cases\n * @param {Boolean=} setCleanedLabel - defaults to true\n * @returns {Array}\n */\nexport function processSourceArray(sourceArray, mapping = {}, setCleanedLabel) {\n    let toReturn = [];\n    let mapValue = mapping['value'];\n    let mapLabel = mapping['label'];\n    for (let i = 0, l = sourceArray.length; i < l; i += 1) {\n        let result = {};\n        let entry = sourceArray[i];\n        // handle array of strings\n        if (typeof entry === 'string') {\n            result.value = result.label = entry;\n        }\n        // handle array of objects - ensure value and label exist, and maintain any other properties\n        else {\n            result = entry;\n            let value = result[mapValue] || result.value || result.label;\n            let label = result[mapLabel] || result.label || result.value;\n            result.value = (value || '').toString();\n            result.label = (label || '').toString();\n        }\n        // whether to set a cleaned label for static source filtering (in filter method)\n        if (setCleanedLabel !== false) {\n            result.cleanedLabel = cleanString(result.label);\n        }\n        toReturn.push(result);\n    }\n    return toReturn;\n}\n","import './closest-polyfill';\r\nimport {\r\n    trimString,\r\n    addClass,\r\n    removeClass,\r\n    cleanString,\r\n    isPrintableKey,\r\n    mergeObjects,\r\n    dispatchEvent,\r\n    setElementState,\r\n    processSourceArray\r\n} from './helpers';\r\n\r\nlet appIndex = 0;\r\n\r\nconst DEFAULT_OPTIONS = {\r\n    /**\r\n     * @description string for async endpoint, array of strings, array of objects with value and label, or function\r\n     * @type {String|String[]|Object[]|Function}\r\n     */\r\n    source: '',\r\n    /** @description properties to use for label and value when using an Array of Objects as source */\r\n    sourceMapping: {},\r\n\r\n    /** @description input delay before running a search */\r\n    delay: 100,\r\n    /** @description min number of characters to run a search (includes spaces) */\r\n    minLength: 1,\r\n    /** @description max number of results to render */\r\n    maxResults: 9999,\r\n    /** @description whether to render a button that triggers showing all options */\r\n    showAllButton: true,\r\n    /** @description confirm selection when blurring off of the control */\r\n    confirmOnBlur: true,\r\n\r\n    /** @description whether to allow multiple items to be selected */\r\n    multiple: false,\r\n    /** @description max number of items that can be selected */\r\n    maxItems: 9999,\r\n    /** @description if element is an input, and in multiple mode, character that separates the values */\r\n    multipleSeparator: ',',\r\n\r\n    /** @description placeholder text to show in generated input */\r\n    placeholder: 'Type to search...',\r\n    /** @description text to show (and announce) if no results found */\r\n    noResultsText: 'No results',\r\n\r\n    /** @description class name to add to list */\r\n    listClassName: '',\r\n    /** @description class name to add to input */\r\n    inputClassName: '',\r\n    /** @description class name to add to component wrapper */\r\n    wrapperClassName: 'form-control',\r\n    /** @description string to use in front of main classes that are used */\r\n    cssNameSpace: 'aria-autocomplete',\r\n\r\n    /** @description when source is a string, param to use when adding input value */\r\n    asyncQueryParam: 'q',\r\n    /** @description when source is a string, param to use when adding results limit */\r\n    asyncMaxResultsParam: 'limit',\r\n\r\n    /** @description in multi mode, screen reader text used for element deletion - prepended to label */\r\n    srDeleteText: 'delete',\r\n    /** @description in multi mode, screen reader text announced after deletion - appended to label */\r\n    srDeletedText: 'deleted',\r\n    /** @description screen reader text announced after selection - appended to label */\r\n    srSelectedText: 'selected',\r\n    /** @description screen reader explainer added to the list element via aria-label attribute */\r\n    srExplanatoryText: 'Search suggestions',\r\n    /** @description screen reader description used for main input when empty */\r\n    srAssistiveText:\r\n        'When autocomplete results are available use up and down arrows to review and enter to select. ' +\r\n        'Touch device users, explore by touch or with swipe gestures.',\r\n    /** @description screen reader announcement after results are rendered */\r\n    srResultsText: length =>\r\n        `${length} ${length === 1 ? 'result' : 'results'} available.`,\r\n\r\n    /** @description callback after async call completes - can be used to format the results */\r\n    onAsyncSuccess: undefined, //  to needed format (onResponse can also be used for this)\r\n    /** @description callback prior to rendering - can be used to format the results */\r\n    onResponse: undefined, // before response is processed and rendered - can be used to modify results\r\n    /** @description callback before search is performed - can be used to affect search value */\r\n    onSearch: undefined,\r\n    /** @description callback after selection is made */\r\n    onSelect: undefined,\r\n    /** @description callback when main script processing and initial rendering has finished */\r\n    onReady: undefined,\r\n    /** @description callback when list area closes */\r\n    onClose: undefined,\r\n    /** @description callback when list area opens */\r\n    onOpen: undefined\r\n};\r\n\r\nclass AriaAutocomplete {\r\n    /**\r\n     * @param {Element} element\r\n     * @param {Object=} options\r\n     */\r\n    constructor(element, options) {\r\n        // fail silently if no list provided\r\n        if (!element) {\r\n            return;\r\n        }\r\n\r\n        // if instance already exists on the list element, do not re-initialise\r\n        if (element.ariaAutocomplete) {\r\n            return element.ariaAutocomplete;\r\n        }\r\n\r\n        appIndex += 1;\r\n        this.element = element;\r\n        this.elementIsInput = element.nodeName === 'INPUT';\r\n        this.elementIsSelect = element.nodeName === 'SELECT';\r\n\r\n        // ids used for DOM queries and accessibility attributes e.g. aria-controls\r\n        this.ids = {};\r\n        this.ids.ELEMENT = element.id;\r\n        this.ids.PREFIX = `${element.id || ''}aria-autocomplete-${appIndex}`;\r\n        this.ids.LIST = `${this.ids.PREFIX}-list`;\r\n        this.ids.INPUT = `${this.ids.PREFIX}-input`;\r\n        this.ids.BUTTON = `${this.ids.PREFIX}-button`;\r\n        this.ids.OPTION = `${this.ids.PREFIX}-option`;\r\n        this.ids.WRAPPER = `${this.ids.PREFIX}-wrapper`;\r\n        this.ids.OPTION_SELECTED = `${this.ids.OPTION}-selected`;\r\n        this.ids.OPTION_SELECTED = `${this.ids.OPTION}-selected`;\r\n        this.ids.SR_ASSISTANCE = `${this.ids.PREFIX}-sr-assistance`;\r\n        this.ids.SR_ANNOUNCEMENTS = `${this.ids.PREFIX}-sr-announcements`;\r\n\r\n        // always have an id on the original element for caching state\r\n        if (!this.ids.ELEMENT) {\r\n            this.ids.ELEMENT = `${this.ids.PREFIX}-element`;\r\n            this.element.setAttribute('id', this.ids.ELEMENT);\r\n        }\r\n\r\n        // vars defined later - elements\r\n        this.list;\r\n        this.input;\r\n        this.wrapper;\r\n        this.showAll;\r\n        this.srAnnouncements;\r\n\r\n        // vars defined later - non elements\r\n        this.xhr;\r\n        this.term;\r\n        this.async;\r\n        this.source;\r\n        this.menuOpen;\r\n        this.multiple;\r\n        this.selected;\r\n        this.disabled;\r\n        this.filtering;\r\n        this.cssNameSpace;\r\n        this.forceShowAll;\r\n        this.filteredSource; // filtered source items to render\r\n        this.currentListHtml;\r\n        this.currentSelectedIndex; // for storing index of currently focused option\r\n\r\n        // timers\r\n        this.filterTimer;\r\n        this.announcementTimer;\r\n        this.componentBlurTimer;\r\n        this.elementChangeEventTimer;\r\n\r\n        this.options = mergeObjects(DEFAULT_OPTIONS, options);\r\n        this.init();\r\n    }\r\n\r\n    /**\r\n     * trigger callbacks included in component options\r\n     * @param {String} name\r\n     * @param {Array=} args\r\n     */\r\n    triggerOptionCallback(name, args) {\r\n        if (typeof this.options[name] === 'function') {\r\n            return this.options[name].apply(this.wrapper, args);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description show element with CSS only - if none provided, set list state to visible\r\n     * @param {Element=} element\r\n     */\r\n    show(element) {\r\n        if (typeof element !== 'undefined') {\r\n            let toRemove = `${this.cssNameSpace}--hide hide hidden`;\r\n            removeClass(element, toRemove);\r\n            return element.removeAttribute('hidden');\r\n        }\r\n\r\n        this.input.setAttribute('aria-expanded', 'true');\r\n        if (this.showAll) {\r\n            let expanded = (!!this.forceShowAll).toString();\r\n            this.showAll.setAttribute('aria-expanded', expanded);\r\n        }\r\n        if (!this.menuOpen) {\r\n            this.show(this.list);\r\n            this.menuOpen = true;\r\n            this.triggerOptionCallback('onOpen', [this.list]);\r\n        }\r\n    }\r\n    /**\r\n     * @description hide element with CSS only - if none provided, set list state to hidden\r\n     * @param {Element=} element\r\n     */\r\n    hide(element) {\r\n        if (typeof element !== 'undefined') {\r\n            addClass(element, `${this.cssNameSpace}--hide hide hidden`);\r\n            return element.setAttribute('hidden', 'hidden');\r\n        }\r\n\r\n        this.currentSelectedIndex = -1;\r\n        this.input.setAttribute('aria-expanded', 'false');\r\n        if (this.showAll) {\r\n            this.showAll.setAttribute('aria-expanded', 'false');\r\n        }\r\n        if (this.menuOpen) {\r\n            this.hide(this.list);\r\n            this.menuOpen = false;\r\n            this.triggerOptionCallback('onClose', [this.list]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description enable autocomplete (e.g. when under maxItems selected)\r\n     */\r\n    enable() {\r\n        if (this.disabled) {\r\n            this.disabled = false;\r\n            this.input.disabled = false;\r\n            let n = this.cssNameSpace;\r\n            removeClass(this.input, `${n}__input--disabled disabled`);\r\n            removeClass(this.wrapper, `${n}__wrapper--disabled disabled`);\r\n            if (this.showAll) {\r\n                this.showAll.setAttribute('tabindex', '0');\r\n                removeClass(this.showAll, `${n}__show-all--disabled disabled`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description disable autocomplete (e.g. when maxItems selected)\r\n     */\r\n    disable() {\r\n        if (!this.disabled) {\r\n            this.disabled = true;\r\n            this.input.disabled = true;\r\n            let n = this.cssNameSpace;\r\n            addClass(this.input, `${n}__input--disabled disabled`);\r\n            addClass(this.wrapper, `${n}__wrapper--disabled disabled`);\r\n            if (this.showAll) {\r\n                this.showAll.setAttribute('tabindex', '-1');\r\n                addClass(this.showAll, `${n}__show-all--disabled disabled`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description check if current input value is contained in a selection of options\r\n     * @param {String} query - string to use - checks input value otherwise\r\n     * @param {Array} options - array of objects with value and label properties\r\n     * @param {String=} prop - prop to check against in options array - defaults to 'label'\r\n     * @returns {Number} index of array entry that matches, or -1 if none found\r\n     */\r\n    isQueryContainedIn(query, options, prop) {\r\n        query = trimString(query || this.input.value).toLowerCase();\r\n        if (query) {\r\n            prop = prop || 'label';\r\n            for (let i = 0, l = options.length; i < l; i += 1) {\r\n                if (trimString(options[i][prop]).toLowerCase() === query) {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * @description make a screen reader announcement\r\n     * @param {String} text\r\n     * @param {Number=} delay\r\n     */\r\n    announce(text, delay) {\r\n        if (!text || !this.srAnnouncements) {\r\n            return;\r\n        }\r\n        // in immediate case, do not user timer\r\n        if (delay === 0) {\r\n            return (this.srAnnouncements.textContent = text);\r\n        }\r\n        delay = typeof delay === 'number' ? delay : 400;\r\n        if (this.announcementTimer) {\r\n            clearTimeout(this.announcementTimer);\r\n        }\r\n        this.announcementTimer = setTimeout(() => {\r\n            this.srAnnouncements.textContent = text;\r\n        }, delay);\r\n    }\r\n\r\n    /**\r\n     * @todo: implement this!\r\n     */\r\n    buildMultiSelected() {}\r\n\r\n    /**\r\n     * @description set the aria-describedby attribute on the input\r\n     */\r\n    setInputDescription() {\r\n        let exists = this.input.getAttribute('aria-describedby');\r\n        let current = trimString(exists || '');\r\n        let describedBy = current.replace(this.ids.SR_ASSISTANCE, '');\r\n\r\n        if (this.input.value.length === 0) {\r\n            describedBy = describedBy + ' ' + this.ids.SR_ASSISTANCE;\r\n        }\r\n\r\n        // set or remove attribute, but only if necessary\r\n        if ((describedBy = trimString(describedBy))) {\r\n            if (describedBy !== current) {\r\n                this.input.setAttribute('aria-describedby', describedBy);\r\n            }\r\n        } else if (exists) {\r\n            this.input.removeAttribute('aria-describedby');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description reset classes and aria-selected attribute for all visible filtered options\r\n     */\r\n    resetOptionAttributes() {\r\n        let cssName = this.cssNameSpace;\r\n        let nodes = this.list.childNodes;\r\n        let l = nodes.length;\r\n\r\n        while (l--) {\r\n            removeClass(nodes[l], `${cssName}__option--focused focused focus`);\r\n            nodes[l].setAttribute('aria-selected', 'false');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description move focus to correct option, or to input (on up and down arrows)\r\n     * @param {Event} event\r\n     * @param {Number} index\r\n     */\r\n    setOptionFocus(event, index) {\r\n        // set aria-selected to false and remove focused class\r\n        this.resetOptionAttributes();\r\n\r\n        // if negative index, or no options available, focus on input\r\n        let options = this.list.childNodes;\r\n        if (index < 0 || !options || !options.length) {\r\n            this.currentSelectedIndex = -1;\r\n            // focus on input, only if event was from another element\r\n            if (event && event.target !== this.input) {\r\n                this.input.focus();\r\n            }\r\n            return;\r\n        }\r\n\r\n        // down arrow on/past last option, focus on last item\r\n        if (index >= options.length) {\r\n            this.currentSelectedIndex = options.length - 1;\r\n            this.setOptionFocus(event, this.currentSelectedIndex);\r\n            return;\r\n        }\r\n\r\n        // if option found, focus...\r\n        let toFocus = options[index];\r\n        if (toFocus && typeof toFocus.getAttribute('tabindex') === 'string') {\r\n            this.currentSelectedIndex = index;\r\n            let toAdd = `${this.cssNameSpace}__option--focused focused focus`;\r\n            addClass(toFocus, toAdd);\r\n            toFocus.setAttribute('aria-selected', 'true');\r\n            toFocus.focus();\r\n            return;\r\n        }\r\n\r\n        // reset index just in case\r\n        this.currentSelectedIndex = -1;\r\n    }\r\n\r\n    /**\r\n     * @description set values and dispatch events based on any DOM elements in the selected array\r\n     */\r\n    setSourceElementValues() {\r\n        let valToSet = [];\r\n        for (let i = 0, l = this.selected.length; i < l; i += 1) {\r\n            let entry = this.selected[i];\r\n            valToSet.push(entry.value);\r\n            setElementState(entry.element, true, this); // element processing\r\n        }\r\n\r\n        // set original input value\r\n        if (this.elementIsInput) {\r\n            let valToSetString = valToSet.join(this.options.multipleSeparator);\r\n            if (valToSetString !== this.element.value) {\r\n                this.element.value = valToSetString;\r\n                dispatchEvent(this.element, 'change');\r\n            }\r\n        }\r\n\r\n        // included in case of multi-select mode used with a <select> element as the source\r\n        if (!this.selected.length && this.elementIsSelect) {\r\n            this.element.value = '';\r\n        }\r\n\r\n        // set disabled state as needed\r\n        if (this.multiple && this.selected.length >= this.options.maxItems) {\r\n            return this.disable();\r\n        }\r\n        this.enable();\r\n    }\r\n\r\n    /**\r\n     * @description select option from the list by index\r\n     * @param {Event} event\r\n     * @param {Number} index\r\n     * @param {Boolean} focusAfterSelection\r\n     */\r\n    handleOptionSelect(event, index, focusAfterSelection) {\r\n        // defensive check for proper index, that the filteredSource exists, and not exceed max items option\r\n        if (\r\n            typeof index !== 'number' ||\r\n            index < 0 ||\r\n            (this.multiple && this.selected.length >= this.options.maxItems) ||\r\n            !this.filteredSource.length ||\r\n            !this.filteredSource[index]\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        // generate new object from the selected item in case of varying original source\r\n        /** @todo: confirm if a new object actually needs to be generated */\r\n        let option = mergeObjects(this.filteredSource[index]);\r\n\r\n        // detect if selected option is already in selected array\r\n        let l = this.selected.length;\r\n        let alreadySelected = false;\r\n        while (l--) {\r\n            if (this.selected[l].value === option.value) {\r\n                alreadySelected = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        this.input.value = this.multiple ? '' : option.label;\r\n\r\n        // reset selected array in single select mode\r\n        if (!alreadySelected && !this.multiple) {\r\n            this.selected = [];\r\n        }\r\n\r\n        // (re)set values of any DOM elements based on selected array\r\n        if (!alreadySelected) {\r\n            this.selected.push(option);\r\n            this.setSourceElementValues();\r\n            this.buildMultiSelected(option); // rebuild multi-selected if needed\r\n        }\r\n\r\n        this.triggerOptionCallback('onSelect', [option]);\r\n        this.announce(`${option.label} ${this.options.srSelectedText}`, 0);\r\n\r\n        // return focus to input\r\n        if (!this.disabled && focusAfterSelection !== false) {\r\n            this.input.focus();\r\n        }\r\n\r\n        // close menu after option selection, and after returning focus to input\r\n        this.hide();\r\n    }\r\n\r\n    /**\r\n     * @description remove selected entries from results if in multiple mode\r\n     * @param {Array} results\r\n     * @returns {Array}\r\n     */\r\n    removeSelectedFromResults(results) {\r\n        if (!this.multiple || !this.selected.length) {\r\n            return results;\r\n        }\r\n        let toReturn = [];\r\n        resultsLoop: for (let i = 0, l = results.length; i < l; i += 1) {\r\n            let selected = this.selected;\r\n            let result = results[i];\r\n            for (let j = 0, k = selected.length; j < k; j += 1) {\r\n                let labelMatch = result.label === selected[j].label;\r\n                if (labelMatch && result.value === selected[j].value) {\r\n                    continue resultsLoop;\r\n                }\r\n            }\r\n            toReturn.push(thisResult);\r\n        }\r\n        return toReturn;\r\n    }\r\n\r\n    /**\r\n     * @description final filtering and render for list options, and render\r\n     * @param {Array} results\r\n     */\r\n    setListOptions(results) {\r\n        let toShow = [];\r\n        let optionId = this.ids.OPTION;\r\n        let cssName = this.cssNameSpace;\r\n        let mapping = this.options.sourceMapping;\r\n        // if in multiple mode, exclude items already in the selected array\r\n        let updated = this.removeSelectedFromResults(results);\r\n        // allow callback to alter the response before rendering\r\n        let callback = this.triggerOptionCallback('onResponse', updated);\r\n\r\n        // now commit to setting the filtered source\r\n        this.filteredSource = callback\r\n            ? processSourceArray(callback, mapping)\r\n            : updated;\r\n        let length = this.filteredSource.length;\r\n\r\n        // build up the list html\r\n        let maxResults = this.options.maxResults;\r\n        for (let i = 0; i < length && i < maxResults; i += 1) {\r\n            toShow.push(\r\n                `<li tabindex=\"-1\" aria-selected=\"false\" role=\"option\" class=\"${cssName}__option\" id=\"${optionId}--${i}\" aria-posinset=\"${i +\r\n                    1}\" aria-setsize=\"${length}\">${\r\n                    this.filteredSource[i].label\r\n                }</li>`\r\n            );\r\n        }\r\n\r\n        // set has-results or no-results class on the list element\r\n        if (toShow.length) {\r\n            addClass(this.list, `${cssName}__list--has-results`);\r\n            removeClass(this.list, `${cssName}__list--no-results`);\r\n        } else {\r\n            removeClass(this.list, `${cssName}__list--has-results`);\r\n            addClass(this.list, `${cssName}__list--no-results`);\r\n        }\r\n\r\n        // no results text handling\r\n        let announce;\r\n        let noText = this.options.noResultsText;\r\n        if (!toShow.length && typeof noText === 'string' && noText.length) {\r\n            announce = noText;\r\n            let optionClass = `${cssName}__option`;\r\n            toShow.push(\r\n                `<li class=\"${optionClass} ${optionClass}--no-results\">${noText}</li>`\r\n            );\r\n        }\r\n\r\n        // remove loading class(es) and reset variables\r\n        this.cancelFilterPrep();\r\n\r\n        // announce to screen reader\r\n        if (!announce) {\r\n            announce = this.triggerOptionCallback('srResultsText', [length]);\r\n        }\r\n        this.announce(announce);\r\n\r\n        // render the list, only if we have to\r\n        // time taken for string comparison is worth it to not have to re-parse and re-render the list\r\n        let newListHtml = toShow.join('');\r\n        if (this.currentListHtml !== newListHtml) {\r\n            this.currentListHtml = newListHtml;\r\n            /** @todo: test innerHTML vs insertAdjacentHtml performance in old IE */\r\n            this.list.innerHTML = newListHtml;\r\n        } else {\r\n            // if list html matches, and not re-rendered, clear aria-selected and focus classes\r\n            this.resetOptionAttributes();\r\n        }\r\n\r\n        // if toShow array is empty, make sure not to render the menu\r\n        if (!toShow.length) {\r\n            this.hide();\r\n            return;\r\n        }\r\n\r\n        this.show();\r\n        // reset forceShowAll must be after .show()\r\n        // aria-expanded attribute on showAllButton is controlled in .show() method\r\n        this.forceShowAll = false;\r\n    }\r\n\r\n    /**\r\n     * @description trigger async call for options to render\r\n     * @param {String} value\r\n     * @param {Boolean=} canCancel\r\n     */\r\n    handleAsync(value, canCancel = true) {\r\n        let options = this.options;\r\n        let mapping = options.mapping;\r\n        let xhr = new XMLHttpRequest();\r\n        let encode = encodeURIComponent;\r\n        let isShowAll = this.forceShowAll;\r\n        let limit = this.selected.length + options.maxResults;\r\n        let limitParam = `${encode(options.asyncMaxResultsParam)}=${limit}`;\r\n        let queryParam = `${encode(options.asyncQueryParam)}=${encode(value)}`;\r\n        let params = `${queryParam}&${limitParam}`;\r\n        let url = this.source + (/\\?/.test(this.source) ? '&' : '?') + params;\r\n\r\n        // abort any current call first\r\n        if (this.xhr) {\r\n            this.xhr.abort();\r\n        }\r\n\r\n        xhr.open('GET', url);\r\n        xhr.onload = () => {\r\n            this.forceShowAll = isShowAll; // return forceShowAll to previous state before the options render\r\n            let callback = this.triggerOptionCallback('onAsyncSuccess', [xhr]);\r\n            let source = callback || xhr.responseText;\r\n            let items = processSourceArray(source, mapping, false);\r\n            this.setListOptions(items);\r\n        };\r\n        xhr.send();\r\n\r\n        // allow the creation of an uncancellable call to use on first load\r\n        if (canCancel !== false) {\r\n            this.xhr = xhr;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description trigger filtering using a value\r\n     * @param {String} value\r\n     */\r\n    filter(value) {\r\n        // fail silently if no value is provided\r\n        if (typeof value === 'undefined') {\r\n            this.cancelFilterPrep();\r\n            return;\r\n        }\r\n\r\n        let forceShowAll = this.forceShowAll;\r\n        let callbackResponse = this.triggerOptionCallback('onSearch', [value]);\r\n        let toReturn = [];\r\n\r\n        // allow onSearch callback to affect the searched value\r\n        // only permitted when not a forceShowAll case\r\n        if (!forceShowAll && typeof callbackResponse === 'string') {\r\n            value = callbackResponse;\r\n        }\r\n\r\n        // store search term - used for comparison in filterPrep\r\n        this.term = value;\r\n\r\n        // async handling\r\n        if (this.async) {\r\n            this.handleAsync(value);\r\n            // set show all to false immediately as may be used in other places\r\n            this.forceShowAll = false;\r\n            return;\r\n        }\r\n\r\n        // handle the source as a function\r\n        if (typeof this.source === 'function') {\r\n            toReturn = this.source.call(this.wrapper, this.term);\r\n            this.setListOptions(toReturn);\r\n            return;\r\n        }\r\n\r\n        // if empty string, show all\r\n        if (!value) {\r\n            forceShowAll = true;\r\n        }\r\n\r\n        // existing list handling\r\n        if (this.source && this.source.length) {\r\n            if (!forceShowAll) {\r\n                value = cleanString(value);\r\n            }\r\n            for (let i = 0, l = this.source.length; i < l; i += 1) {\r\n                let entry = this.source[i];\r\n                if (forceShowAll || entry.cleanedLabel.search(value) !== -1) {\r\n                    toReturn.push({\r\n                        element: entry.element,\r\n                        staticSourceIndex: i,\r\n                        label: entry.label,\r\n                        value: entry.value\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setListOptions(toReturn);\r\n    }\r\n\r\n    /**\r\n     * @description cancel filter timer and remove loading classes\r\n     */\r\n    cancelFilterPrep() {\r\n        if (this.filterTimer) {\r\n            clearTimeout(this.filterTimer);\r\n        }\r\n        let nameSpace = this.cssNameSpace;\r\n        removeClass(this.wrapper, `${nameSpace}__wrapper--loading loading`);\r\n        removeClass(this.input, `${nameSpace}__input--loading loading`);\r\n        this.filtering = false;\r\n    }\r\n\r\n    /**\r\n     * @description checks before filtering, and set filter timer\r\n     * @param {Event} e\r\n     * @param {Boolean=} doValueOverrideCheck - whether to check input value against selected item(s)\r\n     * @param {Boolean=} runNow\r\n     */\r\n    filterPrep(e, doValueOverrideCheck = false, runNow = false) {\r\n        let forceShowAll = this.forceShowAll;\r\n        let delay = forceShowAll || runNow ? 0 : this.options.delay;\r\n\r\n        // clear timers\r\n        this.filtering = true;\r\n        this.cancelFilterPrep();\r\n        this.filterTimer = setTimeout(() => {\r\n            let value = this.input.value;\r\n            // treat as empty search if...\r\n            // forceShowAll, or in single mode and selected item label matches current value\r\n            if (\r\n                forceShowAll ||\r\n                value === '' ||\r\n                (doValueOverrideCheck &&\r\n                    !this.multiple &&\r\n                    this.selected.length &&\r\n                    trimString(this.selected[0].label) === trimString(value))\r\n            ) {\r\n                value = '';\r\n            }\r\n\r\n            // handle aria-describedby\r\n            this.setInputDescription();\r\n\r\n            if (!forceShowAll && value.length < this.options.minLength) {\r\n                this.hide();\r\n                return;\r\n            }\r\n\r\n            // try catch used due to permissions issues in some cases\r\n            let modifier;\r\n            try {\r\n                let keydown = e && e.type === 'keydown';\r\n                modifier = keydown && (e.altKey || e.ctrlKey || e.metaKey); // allow shift key, just in case...\r\n            } catch (e) {}\r\n\r\n            // if value to use matches last used search term, do nothing\r\n            let equalVals = value === this.term;\r\n\r\n            // prevent search being run again with the same value\r\n            if (!equalVals || (equalVals && !this.menuOpen && !modifier)) {\r\n                let n = this.cssNameSpace;\r\n                addClass(this.wrapper, `${n}__wrapper--loading loading`);\r\n                addClass(this.input, `${n}__input--loading loading`);\r\n                this.currentSelectedIndex = -1;\r\n                this.filter(value);\r\n            }\r\n        }, delay);\r\n    }\r\n\r\n    /**\r\n     * @description trigger filter prep in showAll mode\r\n     * @param {Event} event\r\n     */\r\n    filterPrepShowAll(event) {\r\n        event.preventDefault();\r\n        this.forceShowAll = true;\r\n        this.filterPrep(event, false, true);\r\n    }\r\n\r\n    /**\r\n     * @description blur behaviour for hiding list and removing focus class(es)\r\n     * @param {Event} event\r\n     * @param {Boolean} force - fire instantly and force blurring out of the component\r\n     */\r\n    handleComponentBlur(event, force) {\r\n        let delay = force ? 0 : 100;\r\n        if (this.componentBlurTimer) {\r\n            clearTimeout(this.componentBlurTimer);\r\n        }\r\n        // use a timeout to ensure this blur fires after other focus events\r\n        // and in case the user focuses back in immediately\r\n        this.componentBlurTimer = setTimeout(() => {\r\n            // do nothing if blurring to an element within the list\r\n            let activeElem = document.activeElement;\r\n            // exception for show all button\r\n            /** @todo: exception for selected items */\r\n            if (!force && !(this.showAll && this.showAll === activeElem)) {\r\n                // must base this on the wrapper to allow scrolling the list in IE\r\n                if (this.wrapper.contains(activeElem)) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            let isQueryIn = this.isQueryContainedIn.bind(this);\r\n\r\n            // cancel any running async call\r\n            if (this.xhr) {\r\n                this.xhr.abort();\r\n            }\r\n\r\n            // confirmOnBlur behaviour\r\n            if (!force && this.options.confirmOnBlur && this.menuOpen) {\r\n                // if blurring from an option (currentSelectedIndex > -1), select it\r\n                let toUse = this.currentSelectedIndex;\r\n                if (typeof toUse !== 'number' || toUse === -1) {\r\n                    // otherwise check for exact match between current input value and available items\r\n                    toUse = isQueryIn('', this.filteredSource);\r\n                }\r\n                this.handleOptionSelect({}, toUse, false);\r\n            }\r\n\r\n            let n = this.cssNameSpace;\r\n            removeClass(this.wrapper, `${n}__wrapper--focused focused focus`);\r\n            removeClass(this.input, `${n}__input--focused focused focus`);\r\n            this.cancelFilterPrep();\r\n            this.hide();\r\n\r\n            // in single select case, if current value and chosen value differ, clear selected and input value\r\n            if (!this.multiple && isQueryIn('', this.selected) === -1) {\r\n                let isInputOrDdl = this.elementIsInput || this.elementIsSelect;\r\n                if (isInputOrDdl && this.element.value !== '') {\r\n                    this.element.value = '';\r\n                    dispatchEvent(this.element, 'change');\r\n                }\r\n                this.input.value = '';\r\n                this.selected = [];\r\n            }\r\n        }, delay);\r\n    }\r\n\r\n    /**\r\n     * @description enter keydown for selections\r\n     * @param {Event} event\r\n     */\r\n    handleEnterKey(event) {\r\n        /** @todo: if in multiple mode, and event target was a selected item, remove it */\r\n        if (this.multiple) {\r\n        }\r\n\r\n        if (this.disabled) {\r\n            return;\r\n        }\r\n\r\n        if (this.showAll && event.target === this.showAll) {\r\n            this.filterPrepShowAll(event);\r\n            return;\r\n        }\r\n\r\n        if (this.menuOpen) {\r\n            event.preventDefault();\r\n            if (this.currentSelectedIndex > -1) {\r\n                this.handleOptionSelect(event, this.currentSelectedIndex);\r\n            }\r\n        }\r\n\r\n        // if enter keypress was from the filter input, trigger search immediately\r\n        if (event.target === this.input) {\r\n            this.filterPrep(event, false, true);\r\n        }\r\n    }\r\n    /**\r\n     * @description down arrow usage - option focus, or search all\r\n     * @param {Event} event\r\n     */\r\n    handleDownArrowKey(event) {\r\n        event.preventDefault();\r\n        // if closed, and text is long enough, run search\r\n        if (!this.menuOpen) {\r\n            this.forceShowAll = this.options.minLength < 1;\r\n            if (\r\n                this.forceShowAll ||\r\n                this.input.value.length >= this.options.minLength\r\n            ) {\r\n                this.filterPrep(event);\r\n            }\r\n        }\r\n        // move focus to downward option\r\n        if (this.menuOpen && !this.filtering) {\r\n            let current = this.currentSelectedIndex;\r\n            if (typeof current !== 'number' || current < 0) {\r\n                this.setOptionFocus(event, 0);\r\n            } else {\r\n                this.setOptionFocus(event, current + 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description up arrow usage - option focus, or return focus to input\r\n     * @param {Event} event\r\n     */\r\n    handleUpArrowKey(event) {\r\n        event.preventDefault();\r\n        let usable = !this.disabled && this.menuOpen;\r\n        if (usable && typeof this.currentSelectedIndex === 'number') {\r\n            this.setOptionFocus(event, this.currentSelectedIndex - 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description standard keydown handling (excluding enter, up, down, escape)\r\n     * @param {Event} event\r\n     */\r\n    handleKeyDownDefault(event) {\r\n        const targetIsInput = event.target === this.input;\r\n        // on space, if focus state is on any other item, treat as enter\r\n        if (event.keyCode === 32 && !targetIsInput) {\r\n            this.handleEnterKey(event);\r\n        }\r\n\r\n        if (this.disabled) {\r\n            return;\r\n        }\r\n\r\n        // on backspace, if using empty input in multiple mode, delete last selected entry\r\n        let selectedLength = this.selected && this.selected.length;\r\n        if (\r\n            targetIsInput &&\r\n            this.multiple &&\r\n            selectedLength &&\r\n            event.keyCode === 8 &&\r\n            this.input.value === ''\r\n        ) {\r\n            let lastSelectedLabel = this.selected[selectedLength - 1].label;\r\n            let announcement = `${lastSelectedLabel} ${this.options.srDeletedText}`;\r\n            this.announce(announcement, 0);\r\n            this.selected.pop();\r\n            this.buildMultiSelected();\r\n            return;\r\n        }\r\n\r\n        // any printable character not on input, return focus to input\r\n        let focusInput = !targetIsInput && isPrintableKey(event.keyCode);\r\n        if (focusInput) {\r\n            this.input.focus();\r\n        }\r\n\r\n        // trigger filtering - done here, instead of using input event, due to IE9 issues\r\n        if (focusInput || targetIsInput) {\r\n            this.filterPrep(event);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description component keydown handling\r\n     * @param {Event} event\r\n     */\r\n    prepKeyDown(event) {\r\n        switch (event.keyCode) {\r\n            case 13: // on enter\r\n                this.handleEnterKey(event);\r\n                break;\r\n            case 27: // on escape\r\n                this.handleComponentBlur(event, true);\r\n                break;\r\n            case 38: // on up\r\n                this.handleUpArrowKey(event);\r\n                break;\r\n            case 40: // on down\r\n                this.handleDownArrowKey(event);\r\n                break;\r\n            default:\r\n                this.handleKeyDownDefault(event);\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description bind component events to generated elements\r\n     */\r\n    bindEvents() {\r\n        // when focus is moved outside of the component, close everything\r\n        this.wrapper.addEventListener('focusout', event => {\r\n            this.handleComponentBlur(event, false);\r\n        });\r\n        // set wrapper focus state\r\n        this.wrapper.addEventListener('focusin', event => {\r\n            let toAdd = `${this.cssNameSpace}__wrapper--focused focused focus`;\r\n            addClass(this.wrapper, toAdd);\r\n            if (!this.list.contains(event.target)) {\r\n                this.currentSelectedIndex = -1;\r\n            }\r\n        });\r\n        // handle all keydown events inside the component\r\n        this.wrapper.addEventListener('keydown', event => {\r\n            this.prepKeyDown(event);\r\n        });\r\n        // if clicking directly on the wrapper, move focus to the input\r\n        this.wrapper.addEventListener('click', event => {\r\n            if (event.target === this.wrapper) {\r\n                this.input.focus();\r\n            }\r\n        });\r\n\r\n        // when blurring out of input, check current value against selected one and clear if needed\r\n        this.input.addEventListener('blur', () => {\r\n            let toRemove = `${this.cssNameSpace}__input--focused focused focus`;\r\n            removeClass(this.input, toRemove);\r\n        });\r\n        // trigger filter on input event as well as keydown (covering bases)\r\n        this.input.addEventListener('input', event => {\r\n            this.filterPrep(event);\r\n        });\r\n        // when specifically clicking on input, if menu is closed, and value is long enough, search\r\n        this.input.addEventListener('click', event => {\r\n            let open = this.menuOpen;\r\n            if (!open && this.input.value.length >= this.options.minLength) {\r\n                this.filterPrep(event, true);\r\n            }\r\n        });\r\n        // when focusing on input, reset selected index and trigger search handling\r\n        this.input.addEventListener('focusin', () => {\r\n            let toAdd = `${this.cssNameSpace}__input--focused focused focus`;\r\n            addClass(this.input, toAdd);\r\n            if (!this.disabled && !this.menuOpen) {\r\n                this.filterPrep(event, true);\r\n            }\r\n        });\r\n\r\n        // show all button click\r\n        if (this.showAll) {\r\n            this.showAll.addEventListener('click', event => {\r\n                this.filterPrepShowAll(event);\r\n            });\r\n        }\r\n\r\n        // clear any current focus position when hovering into the list\r\n        this.list.addEventListener('mouseenter', event => {\r\n            this.resetOptionAttributes();\r\n        });\r\n        // trigger options selection\r\n        this.list.addEventListener('click', event => {\r\n            if (event.target !== this.list) {\r\n                let childNodes = this.list.childNodes;\r\n                if (childNodes.length) {\r\n                    let nodeIndex = [].indexOf.call(childNodes, event.target);\r\n                    this.handleOptionSelect(event, nodeIndex);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @description set starting source array based on child checkboxes\r\n     */\r\n    prepListSourceCheckboxes() {\r\n        this.multiple = true; // force multiple in this case\r\n        // reset source and use checkboxes\r\n        this.source = [];\r\n        let elements = this.element.querySelectorAll('input[type=\"checkbox\"]');\r\n        for (let i = 0, l = elements.length; i < l; i += 1) {\r\n            let checkbox = elements[i];\r\n            // must have a value other than empty string\r\n            if (!checkbox.value) {\r\n                continue;\r\n            }\r\n            let toPush = { element: checkbox, value: checkbox.value };\r\n            // label searching\r\n            let label = checkbox.closest('label');\r\n            if (!label && checkbox.id) {\r\n                label = document.querySelector('[for=\"' + checkbox.id + '\"]');\r\n            }\r\n            if (label) {\r\n                toPush.label = label.textContent;\r\n            }\r\n            // if no label so far, re-use value\r\n            if (!toPush.label) {\r\n                toPush.label = toPush.value;\r\n            }\r\n            toPush.cleanedLabel = cleanString(toPush.label);\r\n            this.source.push(toPush);\r\n            // add to selected if applicable\r\n            if (checkbox.checked) {\r\n                this.selected.push(toPush);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description set starting source array based on <select> options\r\n     */\r\n    prepListSourceDdl() {\r\n        this.multiple = this.element.multiple; // force multiple to match select\r\n        // reset source and use options\r\n        this.source = [];\r\n        let options = this.element.querySelectorAll('option');\r\n        for (let i = 0, l = options.length; i < l; i += 1) {\r\n            let option = options[i];\r\n            // must have a value other than empty string\r\n            if (!option.value) {\r\n                continue;\r\n            }\r\n            let toPush = {\r\n                element: option,\r\n                value: option.value,\r\n                label: option.textContent\r\n            };\r\n            toPush.cleanedLabel = cleanString(toPush.label);\r\n            this.source.push(toPush);\r\n            // add to selected if applicable\r\n            if (option.selected) {\r\n                this.selected.push(toPush);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description adjust starting source array to format needed, and set selected\r\n     */\r\n    prepListSourceArray() {\r\n        let mapping = this.options.sourceMapping;\r\n        this.source = processSourceArray(this.source, mapping);\r\n\r\n        // build up selected array if starting element was an input, and had a value\r\n        if (this.elementIsInput && this.element.value) {\r\n            let value = this.element.value;\r\n\r\n            // account for multiple mode\r\n            let multiple = this.options.multiple;\r\n            let separator = this.options.multipleSeparator;\r\n            let valueArr = multiple ? value.split(separator) : [value];\r\n\r\n            for (let i = 0, l = valueArr.length; i < l; i += 1) {\r\n                let val = valueArr[i];\r\n                let isQueryIn = this.isQueryContainedIn;\r\n                // make sure it is not already in the selected array\r\n                let isInSelected = isQueryIn(val, this.selected, 'value') > -1;\r\n\r\n                // but is in the source array (check via 'value', not 'label')\r\n                if (!isInSelected) {\r\n                    let indexInSource = isQueryIn(val, this.source, 'value');\r\n                    if (indexInSource > -1) {\r\n                        this.selected.push(this.source[indexInSource]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description adjust set sources to needed format\r\n     */\r\n    prepListSource() {\r\n        this.async = false;\r\n\r\n        // allow complete control over the source handling via custom function\r\n        if (typeof this.source === 'function') {\r\n            return;\r\n        }\r\n\r\n        // string source - treat as async endpoint\r\n        if (typeof this.source === 'string' && this.source.length) {\r\n            return (this.async = true);\r\n        }\r\n\r\n        // array source - copy array\r\n        if (Array.isArray(this.source) && this.source.length) {\r\n            return this.prepListSourceArray();\r\n        }\r\n\r\n        // dropdown source\r\n        if (this.elementIsSelect) {\r\n            return this.prepListSourceDdl();\r\n        }\r\n\r\n        // checkboxlist source\r\n        if (this.element.querySelector('input[type=\"checkbox\"]')) {\r\n            this.prepListSourceCheckboxes();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description set input starting states - aria attributes, disabled state, starting value\r\n     */\r\n    setInputStartingStates() {\r\n        // update corresponding label to now focus on the new input\r\n        let label = document.querySelector('[for=\"' + this.ids.ELEMENT + '\"]');\r\n        if (label) {\r\n            label.ariaAutocompleteOriginalFor = this.ids.ELEMENT;\r\n            label.setAttribute('for', this.ids.INPUT);\r\n        }\r\n\r\n        // update aria-describedby and aria-labelledby attributes if present\r\n        let describedBy = this.element.getAttribute('aria-describedby');\r\n        if (describedBy) {\r\n            this.input.setAttribute('aria-describedby', describedBy);\r\n        }\r\n        let labelledBy = this.element.getAttribute('aria-labelledby');\r\n        if (labelledBy) {\r\n            this.input.setAttribute('aria-labelledby', labelledBy);\r\n        }\r\n\r\n        // if selected item(s) already exists\r\n        if (this.selected.length) {\r\n            // for multi select variant, set selected items\r\n            if (this.multiple) {\r\n                this.buildMultiSelected();\r\n            }\r\n            // for single select variant, set value to match\r\n            else {\r\n                this.input.value = this.selected[0].label || '';\r\n            }\r\n        }\r\n\r\n        // setup input description - done here in case value is affected above\r\n        this.setInputDescription();\r\n\r\n        // disable the control if the invoked element was disabled\r\n        if (!!this.element.disabled) {\r\n            this.disable();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description build and insert component html structure\r\n     */\r\n    setHtml() {\r\n        let o = this.options;\r\n        let cssName = this.cssNameSpace;\r\n        let showAll = this.options.showAll;\r\n        let explainerText = o.srExplanatoryText;\r\n        let listClass = o.listClassName ? ` ${o.listClassName}` : '';\r\n        let inputClass = o.inputClassName ? ` ${o.inputClassName}` : '';\r\n        let wrapperClass = o.wrapperClassName ? ` ${o.wrapperClassName}` : '';\r\n        let explainer = explainerText ? ` aria-label=\"${explainerText}\"` : '';\r\n\r\n        if (showAll) {\r\n            wrapperClass += ` ${cssName}__wrapper--show-all`;\r\n        }\r\n\r\n        let newHtml = [\r\n            `<div id=\"${this.ids.WRAPPER}\" class=\"${cssName}__wrapper${wrapperClass}\">`\r\n        ];\r\n\r\n        // add input\r\n        newHtml.push(\r\n            `<input type=\"text\" autocomplete=\"off\" aria-expanded=\"false\" aria-autocomplete=\"list\" role=\"combobox\" id=\"${this.ids.INPUT}\" placeholder=\"${this.options.placeholder}\" aria-owns=\"${this.ids.LIST}\" aria-placeholder=\"${this.options.placeholder}\" class=\"${cssName}__input${inputClass}\" />`\r\n        );\r\n\r\n        // button to show all available options\r\n        if (showAll) {\r\n            newHtml.push(\r\n                `<span role=\"button\" aria-label=\"Show all\" class=\"${cssName}__show-all\" tabindex=\"0\" id=\"${this.ids.BUTTON}\" aria-expanded=\"false\"></span>`\r\n            );\r\n        }\r\n        // add the list holder\r\n        newHtml.push(\r\n            `<ul id=\"${this.ids.LIST}\" class=\"${cssName}__list${listClass}\" role=\"listbox\" hidden=\"hidden\"${explainer}></ul>`\r\n        );\r\n        // add the screen reader assistance element\r\n        newHtml.push(\r\n            `<span class=\"sr-only ${cssName}__sr-only ${cssName}__sr-assistance\" id=\"${this.ids.SR_ASSISTANCE}\">${this.options.srAssistiveText}</span>`\r\n        );\r\n        // add element for added screen reader announcements\r\n        newHtml.push(\r\n            `<span class=\"sr-only ${cssName}__sr-only ${cssName}__sr-announcements\" id=\"${this.ids.SR_ANNOUNCEMENTS}\" aria-live=\"polite\" aria-atomic=\"true\"></span>`\r\n        );\r\n\r\n        // close all and append\r\n        newHtml.push(`</div>`);\r\n        this.element.insertAdjacentHTML('afterend', newHtml.join(''));\r\n    }\r\n\r\n    /**\r\n     * @todo: refresh method for use after changing options, source, etc.\r\n     */\r\n    refresh() {\r\n        let options = mergeObjects(this.options); // store new object from existing options\r\n        /** @todo: soft destroy in this case */\r\n        this.destroy();\r\n        this.options = options;\r\n        this.init();\r\n    }\r\n\r\n    /**\r\n     * @description destroy component\r\n     */\r\n    destroy() {\r\n        // return original label 'for' attribute back to element id\r\n        let label = document.querySelector('[for=\"' + this.ids.INPUT + '\"]');\r\n        if (label && label.ariaAutocompleteOriginalFor) {\r\n            label.setAttribute('for', label.ariaAutocompleteOriginalFor);\r\n            delete label.ariaAutocompleteOriginalFor;\r\n        }\r\n        // remove the whole wrapper and set all instance properties to null to clean up DOMNode references\r\n        this.element.parentNode.removeChild(this.wrapper);\r\n        for (let i in this) {\r\n            if (this.hasOwnProperty(i)) {\r\n                this[i] = null;\r\n            }\r\n        }\r\n        delete this.element.ariaAutocomplete;\r\n        // re-show original element\r\n        this.show(this.element);\r\n    }\r\n\r\n    /**\r\n     * @description do it!!\r\n     */\r\n    init() {\r\n        this.selected = [];\r\n\r\n        // set these internally so that the component has to be properly refreshed to change them\r\n        this.source = this.options.source;\r\n        this.multiple = this.options.multiple;\r\n        this.cssNameSpace = this.options.cssNameSpace;\r\n\r\n        // create html structure\r\n        this.setHtml();\r\n\r\n        // additional app variables\r\n        this.list = document.getElementById(this.ids.LIST);\r\n        this.input = document.getElementById(this.ids.INPUT);\r\n        this.wrapper = document.getElementById(this.ids.WRAPPER);\r\n        this.showAll = document.getElementById(this.ids.BUTTON);\r\n        this.srAnnouncements = document.getElementById(\r\n            this.ids.SR_ANNOUNCEMENTS\r\n        );\r\n\r\n        // hide element and list manually\r\n        this.hide(this.list); // pass in the list so that the onClose is not triggered\r\n        this.hide(this.element);\r\n\r\n        // set internal source array, from static elements if necessary\r\n        this.prepListSource();\r\n\r\n        // set starting states for input - must be after source has been defined\r\n        this.setInputStartingStates();\r\n\r\n        // bind all necessary events\r\n        this.bindEvents();\r\n\r\n        /** @todo: handling of initial value in async case - other cases handled in setInputStartingStates */\r\n\r\n        /** @todo: store api on original element */\r\n        this.element.ariaAutocomplete = {};\r\n\r\n        // fire onready callback\r\n        this.triggerOptionCallback('onReady');\r\n    }\r\n}\r\n\r\n/**\r\n * @description expose specific function rather than the AriaAutocomplete class\r\n * @param {Element} elem\r\n * @param {Object} options\r\n * @returns {Object}\r\n */\r\nfunction expose(elem, options) {\r\n    let autocomplete = new AriaAutocomplete(elem, options);\r\n    return autocomplete.api;\r\n}\r\n\r\nwindow['AriaAutocomplete'] = expose;\r\nexport default expose;\r\n"]}