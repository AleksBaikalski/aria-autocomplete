{"version":3,"sources":["closest-polyfill.js","autocomplete-helpers.js","autogrow.js","aria-autocomplete.js"],"names":["Element","prototype","matches","msMatchesSelector","webkitMatchesSelector","closest","s","el","parentElement","parentNode","nodeType","CLEANED_LABEL","SELECTED_OPTION","trimString","theString","trim","hasClass","element","className","e","cur","getAttribute","indexOf","addClass","classes","currentValue","current","finalValue","i","cs","split","l","length","setAttribute","removeClass","replace","REGEX_AMPERSAND","REGEX_DUPE_WHITESPACE","REGEX_TO_IGNORE","REGEX_MAKE_SAFE","cleanString","makeSafeForRegex","toLowerCase","isPrintableKey","keyCode","mergeObjects","n","o","p","hasOwnProperty","dispatchEvent","event","document","htmlEvents","createEvent","initEvent","fireEvent","setElementState","selected","instance","nodeName","checked","elementChangeEventTimer","clearTimeout","setTimeout","processSourceArray","sourceArray","mapping","setCleanedLabel","toReturn","mapValue","mapLabel","result","entry","value","label","toString","push","DIV","createElement","htmlToElement","html","innerHTML","firstChild","setCss","style","transferStyles","from","to","properties","fromStyles","getComputedStyle","styles","searchPropFor","prop","regexSafeQuery","name","search","Array","isArray","searchVarPropsFor","obj","props","query","makeQuerySafe","proceed","removeDuplicatesAndLabel","arr","str","j","testSpan","AutoGrow","input","currentString","eventHandler","currentWidth","init","checkAndSet","call","start","selectionStart","selectionEnd","selection","focus","createRange","selectionLength","text","moveStart","position","top","left","width","padding","whiteSpace","body","appendChild","textContent","offsetWidth","clientWidth","metaKey","altKey","placeholder","type","keyCodeIsDelete","keyCodeIsBackspace","getInputSelection","substring","undefined","character","String","fromCharCode","shiftKey","toUpperCase","measureString","removeEventListener","bind","addEventListener","appIndex","DEFAULT_OPTIONS","source","sourceMapping","alsoSearchIn","delay","minLength","maxResults","showAllControl","confirmOnBlur","multiple","autoGrow","maxItems","multipleSeparator","deleteOnBackspace","asyncQueryParam","asyncMaxResultsParam","noResultsText","cssNameSpace","listClassName","inputClassName","wrapperClassName","srDeleteText","srDeletedText","srShowAllText","srSelectedText","srListLabelText","srAssistiveText","srResultsText","onSearch","onAsyncPrep","onAsyncSuccess","onResponse","onItemRender","onConfirm","onDelete","onReady","onClose","onOpen","AriaAutocomplete","options","ariaAutocomplete","open","api","elementIsInput","elementIsSelect","list","wrapper","showAll","srAnnouncements","ids","xhr","term","async","menuOpen","disabled","filtering","forceShowAll","filteredSource","currentListHtml","inputPollingValue","currentSelectedIndex","documentClick","documentClickBound","filterTimer","pollingTimer","announcementTimer","componentBlurTimer","AutoGrowInput","args","context","apply","toRemove","removeAttribute","expanded","show","triggerOptionCallback","hide","trigger","setPollingValue","childNodes","a","isSelectedElem","index","option","splice","buildMultiSelected","announce","disable","enable","currentSelectedElems","getSelectedElems","isInSelected","removeChild","deleteText","fragment","createDocumentFragment","selectedClass","isInDom","span","insertBefore","nowSelectedElems","id","OPTION_SELECTED","LIST","join","toSet","exists","describedBy","SR_ASSISTANCE","cssName","nodes","resetOptionAttributes","target","setOptionFocus","toFocus","toAdd","valToSet","valToSetString","focusAfterSelection","alreadySelected","setInputValue","triggerAutoGrow","setSourceElementValues","results","resultsLoop","k","labelMatch","toShow","updated","removeSelectedFromResults","callback","optionId","OPTION","checkCallback","thisSource","itemContent","noText","optionClass","cancelFilterPrep","newListHtml","isFirstCall","abort","XMLHttpRequest","encode","encodeURIComponent","isShowAll","unlimited","baseAmount","ampersandOrQuestionMark","test","url","onload","readyState","DONE","status","callbackResponse","responseText","items","prepSelectedFromArray","setInputStartingStates","setListOptions","send","handleAsync","check","searchIn","concat","response","nameSpace","doValueOverrideCheck","runNow","setInputDescription","modifier","ctrlKey","equalVals","filter","showAllPrepTimer","preventDefault","filterPrep","force","activeElem","activeElement","contains","isQueryIn","indexOfQueryIn","toUse","handleOptionSelect","removeEntryFromSelected","filterPrepShowAll","targetIsInput","handleEnterKey","selectedLength","printableKey","focusInput","handleComponentBlur","handleUpArrowKey","handleDownArrowKey","handleKeyDownDefault","startPolling","prepKeyDown","wrapperFocusClasses","inputFocusClasses","cancelPolling","nodeIndex","elements","querySelectorAll","checkbox","toPush","querySelector","separator","valueArr","val","indexInSource","prepListSourceFunction","prepListSourceAsync","prepListSourceArray","prepListSourceDdl","prepListSourceCheckboxes","setAriaAttrs","ELEMENT","ariaAutocompleteOriginalFor","INPUT","labelledBy","wrapperClass","newHtml","WRAPPER","inputClass","BUTTON","explainerText","listClass","explainer","SR_ANNOUNCEMENTS","insertAdjacentHTML","close","destroy","PREFIX","setHtml","getElementById","prepListSource","generateApi","bindEvents","window","elem"],"mappings":"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","file":"aria-autocomplete.min.js","sourceRoot":"../src","sourcesContent":["if (!Element.prototype.matches) {\n    Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n}\nif (!Element.prototype.closest) {\n    Element.prototype.closest = function (s) {\n        var el = this;\n        do { \n            if (el.matches(s)) { \n                return el; \n            } \n            el = el.parentElement || el.parentNode; \n        } while (el !== null && el.nodeType === 1);\n        return null;\n    };\n}","export const CLEANED_LABEL = '_ariaAutocompleteCleanedLabel';\nexport const SELECTED_OPTION = '_ariaAutocompleteSelectedOption';\n\n/**\n * @description trim string helper\n * @param {string} theString\n */\nexport function trimString(theString) {\n    return theString == null ? '' : (theString + '').trim();\n}\n\n/**\n * @description check if element has class - support pre `classList`\n * @param {Element} element - element to check class on\n * @param {String} className\n * @returns {Boolean}\n */\nexport function hasClass(element, className) {\n    const e = element;\n    const cur = trimString(e.getAttribute && e.getAttribute('class'));\n    return ` ${cur} `.indexOf(` ${className} `) > -1;\n}\n\n/**\n * @description add class(es) to element - support pre `classList`\n * @param {Element} element - element to add class(es) to\n * @param {String} classes - space delimitted class(es) to add\n */\nexport function addClass(element, classes) {\n    const currentValue = trimString(\n        element.getAttribute && element.getAttribute('class')\n    );\n    const current = ' ' + currentValue + ' ';\n    let finalValue = '';\n\n    for (let i = 0, cs = classes.split(' '), l = cs.length; i < l; i += 1) {\n        if (cs[i] !== '' && current.indexOf(' ' + cs[i] + ' ') === -1) {\n            finalValue += ' ' + cs[i];\n        }\n    }\n    if (currentValue !== (finalValue = trimString(currentValue + finalValue))) {\n        element.setAttribute('class', finalValue);\n    }\n}\n\n/**\n * @description remove class(es) from element - support pre `classList`\n * @param {Element} element - element to add class(es) to\n * @param {String} classes - space delimitted class(es) to remove\n */\nexport function removeClass(element, classes) {\n    const currentValue = trimString(\n        element.getAttribute && element.getAttribute('class')\n    );\n    let finalValue = ' ' + currentValue + ' ';\n\n    for (let i = 0, cs = classes.split(' '), l = cs.length; i < l; i += 1) {\n        finalValue = finalValue.replace(' ' + cs[i] + ' ', ' ');\n    }\n    if (currentValue !== (finalValue = trimString(finalValue))) {\n        element.setAttribute('class', finalValue);\n    }\n}\n\n// regex constants used for string cleaning\nconst REGEX_AMPERSAND = /&/g;\nconst REGEX_DUPE_WHITESPACE = /\\s\\s+/g;\nconst REGEX_TO_IGNORE = /[\\u2018\\u2019',:\\u2013-]/g;\nconst REGEX_MAKE_SAFE = /[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g;\n/**\n * @description clean string of some characters, and make safe for regex searching\n * @param {String} theString\n * @param {Boolean=} makeSafeForRegex\n * @returns {String}\n */\nexport function cleanString(theString, makeSafeForRegex = false) {\n    theString = trimString(theString)\n        .toLowerCase() // case insensitive\n        .replace(REGEX_TO_IGNORE, '') // ignore quotes, commas, colons, and hyphens\n        .replace(REGEX_AMPERSAND, 'and') // treat & and 'and' as the same\n        .replace(REGEX_DUPE_WHITESPACE, ' '); // ignore duplicate whitespace\n    // make safe for regex searching\n    if (makeSafeForRegex) {\n        theString = theString.replace(REGEX_MAKE_SAFE, '\\\\$&');\n    }\n    return theString;\n}\n\n/**\n * @description check if keycode is for a printable/width-affecting character\n * @param {Number} keyCode\n * @returns {Boolean}\n */\nexport function isPrintableKey(keyCode) {\n    return (\n        (keyCode >= 48 && keyCode <= 57) || // 0-9\n        (keyCode >= 65 && keyCode <= 90) || // a-z\n        (keyCode >= 96 && keyCode <= 111) || // numpad 0-9, numeric operators\n        (keyCode >= 186 && keyCode <= 222) || // semicolon, equal, comma, dash, etc.\n        keyCode === 32 || // space\n        keyCode === 8 || // backspace\n        keyCode === 46 // delete\n    );\n}\n\n/**\n * @description merge objects together to generate a new one\n * @param {Object} args - objects to merge together\n * @returns {Object}\n */\nexport function mergeObjects(...args) {\n    const n = {};\n    for (let i = 0, l = args.length; i < l; i += 1) {\n        const o = args[i];\n        for (let p in o) {\n            if (o.hasOwnProperty(p) && typeof o[p] !== 'undefined') {\n                n[p] = o[p];\n            }\n        }\n    }\n    return n;\n}\n\n/**\n * @description dispatch event helper\n * @param {Element} element\n * @param {String} event\n */\nexport function dispatchEvent(element, event) {\n    if ('createEvent' in document) {\n        const htmlEvents = document.createEvent('HTMLEvents');\n        htmlEvents.initEvent(event, true, true);\n        element.dispatchEvent(htmlEvents);\n    } else {\n        element.fireEvent('on' + event);\n    }\n}\n\n/**\n * @description set element option or checkbox to specified state and trigger change event\n * @param {Element} element\n * @param {Boolean} selected\n * @param {(AriaAutocomplete|Object)} instance\n */\nexport function setElementState(element, selected, instance) {\n    selected = !!selected;\n    if (element) {\n        // handle checkbox\n        if (\n            element.nodeName === 'INPUT' &&\n            typeof element.checked === 'boolean' &&\n            element.checked !== selected\n        ) {\n            element.checked = selected;\n            dispatchEvent(element, 'change');\n        }\n\n        // handle dropdown option\n        if (element.nodeName === 'OPTION' && element.selected !== selected) {\n            element.selected = selected;\n            // ensure change event only fires once for dropdown\n            if (instance.elementChangeEventTimer) {\n                clearTimeout(instance.elementChangeEventTimer);\n            }\n            instance.elementChangeEventTimer = setTimeout(function() {\n                dispatchEvent(element.closest('select'), 'change');\n            }, 1);\n        }\n    }\n}\n\n/**\n * @description process an array of strings or objects to ensure needed props exist\n * @param {(String|Object)[]} sourceArray\n * @param {Object=} mapping - value and label mapping used in object cases\n * @param {Boolean=} setCleanedLabel - defaults to true\n * @returns {Array}\n */\nexport function processSourceArray(sourceArray, mapping = {}, setCleanedLabel) {\n    const toReturn = [];\n    const mapValue = mapping['value'];\n    const mapLabel = mapping['label'];\n    for (let i = 0, l = sourceArray.length; i < l; i += 1) {\n        let result = {};\n        let entry = sourceArray[i];\n        // handle array of strings\n        if (typeof entry === 'string') {\n            result.value = result.label = entry;\n        }\n        // handle array of objects - ensure value and label exist, and maintain any other properties\n        else {\n            // generate new object to not modify original\n            result = mergeObjects(entry);\n            const value = result[mapValue] || result.value || result.label;\n            const label = result[mapLabel] || result.label || result.value;\n            result.value = (value || '').toString();\n            result.label = (label || '').toString();\n        }\n        // whether to set a cleaned label for static source filtering (in filter method)\n        if (setCleanedLabel !== false) {\n            result[CLEANED_LABEL] = cleanString(result.label);\n        }\n        toReturn.push(result);\n    }\n    return toReturn;\n}\n\nconst DIV = document.createElement('div');\n/**\n * @description convert HTML string into an element\n * @param {String} html\n * @returns {Element}\n */\nexport function htmlToElement(html) {\n    DIV.innerHTML = trimString(html);\n    return DIV.firstChild;\n}\n\n/**\n * @description set styles on an element\n * @param {Element} element\n * @param {Object} s\n */\nexport function setCss(element, s) {\n    if (!element) {\n        return;\n    }\n    for (let i in s) {\n        const style = typeof s[i] === 'number' ? s[i] + 'px' : s[i];\n        element.style[i] = style + ''; // force to be a string\n    }\n}\n\n/**\n * @description transfer styles from one Element to another\n * @param {Element} from\n * @param {Element} to\n * @param {Array=} properties\n */\nexport function transferStyles(from, to, properties) {\n    if (!from || !to) {\n        return;\n    }\n    const fromStyles = getComputedStyle(from);\n    let styles = {};\n\n    if (properties && properties.length) {\n        for (let i = 0, l = properties.length; i < l; i += 1) {\n            styles[properties[i]] = fromStyles[properties[i]];\n        }\n    } else {\n        styles = fromStyles;\n    }\n\n    setCss(to, styles);\n}\n\n/**\n * @description search String or Array for another string - partial match\n * @param {String|Array} prop\n * @param {String} regexSafeQuery\n * @param {String=} name\n */\nconst searchPropFor = (prop, regexSafeQuery, name) => {\n    if (typeof prop === 'string') {\n        if (name !== CLEANED_LABEL) {\n            prop = cleanString(prop, false);\n        }\n        return prop.search(regexSafeQuery) !== -1;\n    } else if (Array.isArray(prop)) {\n        for (let i = 0, l = prop.length; i < l; i += 1) {\n            if (searchPropFor(prop[i], regexSafeQuery)) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\n/**\n * @description check through object's String or String[] properties for query match\n * @param {Object} obj\n * @param {String[]} props\n * @param {String} query\n * @param {Boolean=} makeQuerySafe\n * @returns {Boolean}\n */\nexport function searchVarPropsFor(obj, props, query, makeQuerySafe = false) {\n    if (makeQuerySafe) {\n        query = cleanString(query, true);\n    }\n\n    for (let i in obj) {\n        if (obj.hasOwnProperty(i)) {\n            let proceed = false;\n            // check if obj property is a string, and if property name is in props Array\n            if (typeof obj[i] === 'string') {\n                // use while loop instead of indexOf for performance in older browsers\n                let l = props.length;\n                while (l--) {\n                    if (props[l] === i) {\n                        proceed = true;\n                        break;\n                    }\n                }\n            } else {\n                // if not a string, only allow Arrays otherwise\n                proceed = Array.isArray(obj[i]);\n            }\n            if (proceed && searchPropFor(obj[i], query, i)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * @description remove duplicate array entries, and `label`\n * @param {Array} arr\n * @returns {String[]}\n */\nexport function removeDuplicatesAndLabel(arr) {\n    // remove `label` (we will be using CLEANED_LABEL) and duplicates from props array\n    const result = [];\n    for (let i = 0, l = arr.length; i < l; i += 1) {\n        if (typeof arr[i] !== 'string') {\n            continue;\n        }\n        const str = trimString(arr[i]);\n        let proceed = str !== 'label';\n        let j = result.length;\n        while (proceed && j--) {\n            if (result[j] === str) {\n                proceed = false;\n            }\n        }\n        if (proceed) {\n            result.push(str);\n        }\n    }\n    return result;\n}\n","import { isPrintableKey, setCss, transferStyles } from './autocomplete-helpers';\r\n\r\n/**\r\n * @description storage for element used to detect value width\r\n */\r\nlet testSpan;\r\n\r\n/**\r\n * @description set an input element to autogrow based on its value\r\n * @param {Element} input\r\n */\r\nexport default class AutoGrow {\r\n    constructor(input) {\r\n        this.input = input;\r\n        this.currentString;\r\n        this.eventHandler;\r\n        this.currentWidth;\r\n        this.init();\r\n    }\r\n\r\n    /**\r\n     * @description trigger an autogrow check\r\n     */\r\n    trigger() {\r\n        this.checkAndSet.call(this);\r\n    }\r\n\r\n    /**\r\n     * @description get current user selection from within the input\r\n     */\r\n    getInputSelection() {\r\n        const result = {};\r\n        if ('selectionStart' in this.input) {\r\n            result.start = this.input.selectionStart;\r\n            result.length = this.input.selectionEnd - result.start;\r\n        } else if (document.selection) {\r\n            this.input.focus();\r\n            const selection = document.selection.createRange();\r\n            const selectionLength = selection.text.length;\r\n            selection.moveStart('character', -this.input.value.length);\r\n            result.start = selection.text.length - selectionLength;\r\n            result.length = selectionLength;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @description measure the pixel width of a string in an input\r\n     * @param {String} str\r\n     * @returns {Number}\r\n     */\r\n    measureString(str) {\r\n        if (!str) {\r\n            this.currentString = str;\r\n            return 0;\r\n        }\r\n\r\n        // check for matching string\r\n        // risky, as styles could change between checks, but better for performance\r\n        if (str === this.currentString) {\r\n            return this.currentWidth;\r\n        }\r\n\r\n        if (!testSpan) {\r\n            testSpan = document.createElement('span');\r\n            setCss(testSpan, {\r\n                position: 'absolute',\r\n                top: -99999,\r\n                left: -99999,\r\n                width: 'auto',\r\n                padding: 0,\r\n                whiteSpace: 'pre'\r\n            });\r\n            document.body.appendChild(testSpan);\r\n        }\r\n\r\n        testSpan.textContent = str;\r\n        this.currentString = str;\r\n\r\n        transferStyles(this.input, testSpan, [\r\n            'letterSpacing',\r\n            'fontSize',\r\n            'fontFamily',\r\n            'fontWeight',\r\n            'textTransform'\r\n        ]);\r\n\r\n        return testSpan.offsetWidth || testSpan.clientWidth;\r\n    }\r\n\r\n    /**\r\n     * @description check the current input value and set width\r\n     * @param {Event} event\r\n     */\r\n    checkAndSet(event = {}) {\r\n        if (event.metaKey || event.altKey) {\r\n            return;\r\n        }\r\n\r\n        let value = this.input.value;\r\n        if (event.type && event.type.toLowerCase() === 'keydown') {\r\n            const keyCode = event.keyCode;\r\n            const keyCodeIsDelete = keyCode === 46;\r\n            const keyCodeIsBackspace = keyCode === 8;\r\n\r\n            // delete or backspace\r\n            if (keyCodeIsDelete || keyCodeIsBackspace) {\r\n                const selection = this.getInputSelection();\r\n                if (selection.length) {\r\n                    value =\r\n                        value.substring(0, selection.start) +\r\n                        value.substring(selection.start + selection.length);\r\n                } else if (keyCodeIsBackspace && selection.start) {\r\n                    value =\r\n                        value.substring(0, selection.start - 1) +\r\n                        value.substring(selection.start + 1);\r\n                } else if (keyCodeIsDelete && selection.start !== undefined) {\r\n                    value =\r\n                        value.substring(0, selection.start) +\r\n                        value.substring(selection.start + 1);\r\n                }\r\n            }\r\n\r\n            // any other width affecting character\r\n            else if (isPrintableKey(keyCode)) {\r\n                let character = String.fromCharCode(keyCode);\r\n                if (event.shiftKey) {\r\n                    character = character.toUpperCase();\r\n                } else {\r\n                    character = character.toLowerCase();\r\n                }\r\n                value += character;\r\n            }\r\n        }\r\n\r\n        let placeholder;\r\n        if (!value && (placeholder = this.input.getAttribute('placeholder'))) {\r\n            value = placeholder;\r\n        }\r\n\r\n        const width = this.measureString(value) + 4;\r\n        if (width !== this.currentWidth) {\r\n            this.currentWidth = width;\r\n            this.input.style.width = `${width}px`;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description destroy the autogrow behaviour\r\n     */\r\n    destroy() {\r\n        this.input.removeEventListener('blur', this.eventHandler);\r\n        this.input.removeEventListener('input', this.eventHandler);\r\n        this.input.removeEventListener('keyup', this.eventHandler);\r\n        this.input.removeEventListener('keydown', this.eventHandler);\r\n        this.input = null;\r\n    }\r\n\r\n    /**\r\n     * @description initialise the autogrow behaviour and bind events\r\n     */\r\n    init() {\r\n        this.checkAndSet();\r\n        this.eventHandler = this.checkAndSet.bind(this);\r\n        this.input.addEventListener('blur', this.eventHandler);\r\n        this.input.addEventListener('input', this.eventHandler);\r\n        this.input.addEventListener('keyup', this.eventHandler);\r\n        this.input.addEventListener('keydown', this.eventHandler);\r\n    }\r\n}\r\n","import './closest-polyfill';\r\nimport AutoGrow from './autogrow';\r\nimport {\r\n    CLEANED_LABEL,\r\n    SELECTED_OPTION,\r\n    trimString,\r\n    hasClass,\r\n    addClass,\r\n    removeClass,\r\n    cleanString,\r\n    isPrintableKey,\r\n    mergeObjects,\r\n    dispatchEvent,\r\n    setElementState,\r\n    processSourceArray,\r\n    htmlToElement,\r\n    searchVarPropsFor,\r\n    removeDuplicatesAndLabel\r\n} from './autocomplete-helpers';\r\n\r\nlet appIndex = 0;\r\n\r\nconst DEFAULT_OPTIONS = {\r\n    /**\r\n     * @description Give the autocomplete a name to be included in form submissions\r\n     * (Instead of using this option, I would advise initialising the autocomplete on\r\n     * an existing input that will be submitted, to also use any existing validation;\r\n     * this approach is also compatible with the control in multiple mode)\r\n     */\r\n    name: '',\r\n    /**\r\n     * @type {String | String[] | Object[] | Function}\r\n     * @description Specify source. See examples file for more specific usage.\r\n     * @example ['Afghanistan', 'Albania', 'Algeria', ...more]\r\n     * @example (query, render) => render(arrayToUse)\r\n     */\r\n    source: '',\r\n    /**\r\n     * @description Properties to use for label and value\r\n     * when source is an Array of Objects\r\n     */\r\n    sourceMapping: {},\r\n    /**\r\n     * @type {String[]}\r\n     * @description Additional properties to use when searching for a match.\r\n     * `label` will always be used\r\n     */\r\n    alsoSearchIn: [],\r\n\r\n    /**\r\n     * @description Input delay after typing before running a search\r\n     */\r\n    delay: 100,\r\n    /**\r\n     * @description Minimum number of characters to run a search (includes spaces)\r\n     */\r\n    minLength: 1,\r\n    /**\r\n     * @description Maximum number of results to render. Also used with async endpoint\r\n     */\r\n    maxResults: 9999,\r\n    /**\r\n     * @description Render a control that triggers showing all options.\r\n     * Runs a search with an empty query: '', and maxResults of 9999\r\n     */\r\n    showAllControl: false,\r\n    /**\r\n     * Confirm currently active selection when blurring off of the control. If\r\n     * no active selection, will compare current input value against available labels\r\n     */\r\n    confirmOnBlur: true,\r\n\r\n    /**\r\n     * @description Allow multiple items to be selected\r\n     */\r\n    multiple: false,\r\n    /**\r\n     * @description Adjust input width to match its value.\r\n     * Experimental, and a performance hit\r\n     */\r\n    autoGrow: false,\r\n    /**\r\n     * @description Maximum number of items that can be selected\r\n     */\r\n    maxItems: 9999,\r\n    /**\r\n     * @description If initialised element is an input, and in multiple mode,\r\n     * character that separates the selected values e.g. \"GLP,ZWE\"\r\n     */\r\n    multipleSeparator: ',',\r\n    /**\r\n     * @description If input is empty and in multiple mode,\r\n     * delete last selected item on backspace\r\n     */\r\n    deleteOnBackspace: false,\r\n\r\n    /**\r\n     * @description In async mode, parameter to use when adding the input value\r\n     * to the endpoint String. e.g. https://some-endpoint?q=norway&limit=9999\r\n     */\r\n    asyncQueryParam: 'q',\r\n    /**\r\n     * @description In async mode, parameter to use when adding results limit\r\n     * to the endpoint String. e.g. https://some-endpoint?q=norway&limit=9999\r\n     */\r\n    asyncMaxResultsParam: 'limit',\r\n\r\n    /**\r\n     * @description Placeholder text to show in generated input\r\n     */\r\n    placeholder: '',\r\n    /**\r\n     * @description Text to show (and announce to screen readers) if no results found.\r\n     * If empty, the list of options will remain hidden when there are no results\r\n     */\r\n    noResultsText: 'No results',\r\n    /**\r\n     * @description String to prepend to classes for BEM naming\r\n     * e.g. aria-autocomplete__input\r\n     */\r\n    cssNameSpace: 'aria-autocomplete',\r\n    /**\r\n     * @description Custom class name to add to the options list holder\r\n     */\r\n    listClassName: '',\r\n    /**\r\n     * @description Custom class name to add to the generated input\r\n     */\r\n    inputClassName: '',\r\n    /**\r\n     * @description Custom class name to add to the component wrapper\r\n     */\r\n    wrapperClassName: '',\r\n\r\n    /**\r\n     * @description In multiple mode, screen reader text used for element deletion.\r\n     * Prepended to option label in aria-label attribute e.g. 'delete Canada'\r\n     */\r\n    srDeleteText: 'delete',\r\n    /**\r\n     * @description Screen reader text announced after deletion.\r\n     * Apended to option label e.g. 'Canada deleted'\r\n     */\r\n    srDeletedText: 'deleted',\r\n    /**\r\n     * @description Value for aria-label attribute on the show all control\r\n     */\r\n    srShowAllText: 'Show all',\r\n    /**\r\n     * @description Screen reader text announced after confirming a selection.\r\n     * Appended to option label e.g. 'Canada selected'\r\n     */\r\n    srSelectedText: 'selected',\r\n    /**\r\n     * @description Screen reader explainer added to the list element\r\n     * via aria-label attribute\r\n     */\r\n    srListLabelText: 'Search suggestions',\r\n    /**\r\n     * @description Screen reader description announced when the input receives focus.\r\n     * Only announced when input is empty\r\n     */\r\n    srAssistiveText:\r\n        'When results are available use up and down arrows to review and ' +\r\n        'enter to select. Touch device users, explore by touch or with swipe gestures.',\r\n    /**\r\n     * @description Screen reader announcement after results are rendered\r\n     */\r\n    srResultsText: length =>\r\n        `${length} ${length === 1 ? 'result' : 'results'} available.`,\r\n\r\n    /**\r\n     * @description Callback before a search is performed - receives the input value.\r\n     * Can be used to alter the search value by returning a String\r\n     */\r\n    onSearch: undefined,\r\n    /**\r\n     * @description Callback before async call is made - receives the URL.\r\n     * Can be used to format the endpoint URL by returning a String\r\n     */\r\n    onAsyncPrep: undefined,\r\n    /**\r\n     * @description Callback after async call completes - receives the xhr object.\r\n     * Can be used to format the results by returning an Array\r\n     */\r\n    onAsyncSuccess: undefined,\r\n    /**\r\n     * @description Callback prior to rendering - receives the options that are going\r\n     * to render. Can be used to format the results by returning an Array\r\n     */\r\n    onResponse: undefined,\r\n    /**\r\n     * @description Callback when rendering items in the list.\r\n     * Can be used to format the <li> content by returning a String\r\n     */\r\n    onItemRender: undefined,\r\n    /**\r\n     * @description Callback after selection is made -\r\n     * receives an object with the option details\r\n     */\r\n    onConfirm: undefined,\r\n    /**\r\n     * @description Callback after an autocomplete selection is deleted.\r\n     * Fires in single-select mode when selection is deleted automatically.\r\n     * Fires in multi-select mode when selected is deleted by user action\r\n     */\r\n    onDelete: undefined,\r\n    /**\r\n     * @description Callback when main script processing and initial rendering has finished\r\n     */\r\n    onReady: undefined,\r\n    /**\r\n     * @description Callback when list area closes - receives the list holder element\r\n     */\r\n    onClose: undefined,\r\n    /**\r\n     * @description Callback when list area opens - receives the list holder element\r\n     */\r\n    onOpen: undefined\r\n};\r\n\r\n/**\r\n * @param {Element} element\r\n * @param {Object=} options\r\n */\r\nclass AriaAutocomplete {\r\n    constructor(element, options) {\r\n        // fail silently if no list provided\r\n        if (!element) {\r\n            return;\r\n        }\r\n\r\n        // if instance already exists on the list element, do not re-initialise\r\n        if (element.ariaAutocomplete && element.ariaAutocomplete.open) {\r\n            return { api: element.ariaAutocomplete };\r\n        }\r\n\r\n        // vars defined later - related explicitly to core initialising params\r\n        this.options;\r\n        this.element;\r\n        this.elementIsInput;\r\n        this.elementIsSelect;\r\n\r\n        // vars defined later - elements\r\n        this.list;\r\n        this.input;\r\n        this.wrapper;\r\n        this.showAll;\r\n        this.srAnnouncements;\r\n\r\n        // vars defined later - non elements\r\n        this.ids;\r\n        this.xhr;\r\n        this.term;\r\n        this.async;\r\n        this.source;\r\n        this.menuOpen;\r\n        this.multiple;\r\n        this.selected;\r\n        this.disabled;\r\n        this.autoGrow;\r\n        this.filtering;\r\n        this.cssNameSpace;\r\n        this.forceShowAll;\r\n        this.filteredSource; // filtered source items to render\r\n        this.currentListHtml;\r\n        this.inputPollingValue;\r\n        this.currentSelectedIndex; // for storing index of currently focused option\r\n\r\n        // document click\r\n        this.documentClick;\r\n        this.documentClickBound;\r\n\r\n        // timers\r\n        this.filterTimer;\r\n        this.pollingTimer;\r\n        this.announcementTimer;\r\n        this.componentBlurTimer;\r\n        this.elementChangeEventTimer;\r\n\r\n        // storage for autoGrow class\r\n        this.AutoGrowInput;\r\n\r\n        // get going!\r\n        this.init(element, options);\r\n    }\r\n\r\n    /**\r\n     * trigger callbacks included in component options\r\n     * @param {String} name\r\n     * @param {Array=} args\r\n     * @param {Any=} context\r\n     */\r\n    triggerOptionCallback(name, args, context) {\r\n        context = typeof context === 'undefined' ? this.api : context;\r\n        if (typeof this.options[name] === 'function') {\r\n            return this.options[name].apply(context, args);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description show element with CSS only - if none provided, set list state to visible\r\n     * @param {Element=} element\r\n     */\r\n    show(element) {\r\n        if (typeof element !== 'undefined') {\r\n            const toRemove = `${this.cssNameSpace}--hide hide hidden`;\r\n            removeClass(element, toRemove);\r\n            return element.removeAttribute('hidden');\r\n        }\r\n\r\n        this.input.setAttribute('aria-expanded', 'true');\r\n        if (this.showAll) {\r\n            const expanded = (!!this.forceShowAll).toString();\r\n            this.showAll.setAttribute('aria-expanded', expanded);\r\n        }\r\n        if (!this.menuOpen) {\r\n            this.show(this.list);\r\n            this.menuOpen = true;\r\n            this.triggerOptionCallback('onOpen', [this.list]);\r\n            if (!this.documentClickBound) {\r\n                this.documentClickBound = true;\r\n                document.addEventListener('click', this.documentClick);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @description hide element with CSS only - if none provided, set list state to hidden\r\n     * @param {Element=} element\r\n     */\r\n    hide(element) {\r\n        if (typeof element !== 'undefined') {\r\n            addClass(element, `${this.cssNameSpace}--hide hide hidden`);\r\n            return element.setAttribute('hidden', 'hidden');\r\n        }\r\n\r\n        this.currentSelectedIndex = -1;\r\n        this.input.setAttribute('aria-expanded', 'false');\r\n        if (this.showAll) {\r\n            this.showAll.setAttribute('aria-expanded', 'false');\r\n        }\r\n        if (this.menuOpen) {\r\n            this.hide(this.list);\r\n            this.menuOpen = false;\r\n            this.triggerOptionCallback('onClose', [this.list]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description enable autocomplete (e.g. when under maxItems selected)\r\n     */\r\n    enable() {\r\n        if (this.disabled) {\r\n            this.disabled = false;\r\n            this.input.disabled = false;\r\n            const n = this.cssNameSpace;\r\n            removeClass(this.input, `${n}__input--disabled disabled`);\r\n            removeClass(this.wrapper, `${n}__wrapper--disabled disabled`);\r\n            if (this.showAll) {\r\n                this.showAll.setAttribute('tabindex', '0');\r\n                removeClass(this.showAll, `${n}__show-all--disabled disabled`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description disable autocomplete (e.g. when maxItems selected)\r\n     */\r\n    disable() {\r\n        if (!this.disabled) {\r\n            this.disabled = true;\r\n            this.input.disabled = true;\r\n            const n = this.cssNameSpace;\r\n            addClass(this.input, `${n}__input--disabled disabled`);\r\n            addClass(this.wrapper, `${n}__wrapper--disabled disabled`);\r\n            if (this.showAll) {\r\n                this.showAll.setAttribute('tabindex', '-1');\r\n                addClass(this.showAll, `${n}__show-all--disabled disabled`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description trigger input resizing if autogrow is enabled\r\n     */\r\n    triggerAutoGrow() {\r\n        if (this.autoGrow && this.AutoGrowInput) {\r\n            this.AutoGrowInput.trigger();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description set input value to specific string, and related component vars\r\n     * @param {String} value\r\n     * @param {Boolean=} setPollingValue\r\n     */\r\n    setInputValue(value, setPollingValue = false) {\r\n        this.input.value = this.term = value;\r\n        if (setPollingValue) {\r\n            this.inputPollingValue = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description check if current input value is contained in a selection of options\r\n     * @param {Array} options - array of objects with value and label properties\r\n     * @param {String=} query - string to use - checks input value otherwise\r\n     * @param {String=} prop - prop to check against in options array - defaults to 'label'\r\n     * @returns {Number} index of array entry that matches, or -1 if none found\r\n     */\r\n    indexOfQueryIn(options, query = this.input.value, prop) {\r\n        query = trimString(query).toLowerCase();\r\n        if (query) {\r\n            prop = prop || 'label';\r\n            for (let i = 0, l = options.length; i < l; i += 1) {\r\n                if (trimString(options[i][prop]).toLowerCase() === query) {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * @description make a screen reader announcement\r\n     * @param {String} text\r\n     * @param {Number=} delay\r\n     */\r\n    announce(text, delay) {\r\n        if (!text || !this.srAnnouncements) {\r\n            return;\r\n        }\r\n        // in immediate case, do not user timer\r\n        if (delay === 0) {\r\n            return (this.srAnnouncements.textContent = text);\r\n        }\r\n        delay = typeof delay === 'number' ? delay : 400;\r\n        if (this.announcementTimer) {\r\n            clearTimeout(this.announcementTimer);\r\n        }\r\n        this.announcementTimer = setTimeout(() => {\r\n            this.srAnnouncements.textContent = text;\r\n        }, delay);\r\n    }\r\n\r\n    /**\r\n     * @description check if element is a selected element in the DOM\r\n     * @param {Element} element\r\n     * @returns {Boolean}\r\n     */\r\n    isSelectedElem(element) {\r\n        return (\r\n            this.multiple &&\r\n            element[SELECTED_OPTION] &&\r\n            hasClass(element, `${this.cssNameSpace}__selected`)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @description get DOM elements for selected items\r\n     * @returns {Element[]}\r\n     */\r\n    getSelectedElems() {\r\n        const n = this.wrapper.childNodes;\r\n        const a = [];\r\n        for (let i = 0, l = n.length; i < l; i += 1) {\r\n            if (this.isSelectedElem(n[i])) {\r\n                a.push(n[i]);\r\n            }\r\n        }\r\n        return a;\r\n    }\r\n\r\n    /**\r\n     * @description remove object from selected\r\n     * @param {Object} entry\r\n     */\r\n    removeEntryFromSelected(entry) {\r\n        let index = this.selected.indexOf(entry);\r\n        if (index === -1) {\r\n            // value check, in case explicit object reference did not work\r\n            for (let i = 0, l = this.selected.length; i < l; i += 1) {\r\n                if (this.selected[i].value === entry.value) {\r\n                    index = i;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // set element state, dispatch change event, set selected array,\r\n        // trigger callback, build selected, and do screen reader announcement\r\n        if (index > -1 && this.selected[index]) {\r\n            const option = mergeObjects(this.selected[index]);\r\n            const label = option.label;\r\n            setElementState(option.element, false, this);\r\n            this.selected.splice(index, 1);\r\n            this.triggerOptionCallback('onDelete', [option]);\r\n            this.buildMultiSelected();\r\n            this.announce(`${label} ${this.options.srDeletedText}`, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description re-build the html showing the selected items\r\n     * note: there are a lot of loops here - could affect performance\r\n     */\r\n    buildMultiSelected() {\r\n        // only do anything in multiple mode\r\n        if (!this.multiple) {\r\n            return;\r\n        }\r\n\r\n        // disable or enable as needed\r\n        if (this.multiple && this.selected.length >= this.options.maxItems) {\r\n            this.disable();\r\n        } else {\r\n            this.enable();\r\n        }\r\n\r\n        // no elements, and none selected, do nothing\r\n        const currentSelectedElems = this.getSelectedElems();\r\n        if (!this.selected.length && !currentSelectedElems.length) {\r\n            return;\r\n        }\r\n\r\n        // cycle through existing elements, and remove any not in the selected array\r\n        const current = [];\r\n        let i = currentSelectedElems.length;\r\n        while (i--) {\r\n            let option = currentSelectedElems[i][SELECTED_OPTION];\r\n            let l = this.selected.length;\r\n            let isInSelected = false;\r\n            while (l--) {\r\n                let selected = this.selected[l];\r\n                if (selected === option || selected.value === option.value) {\r\n                    isInSelected = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (isInSelected) {\r\n                current.push(currentSelectedElems[i]);\r\n            } else {\r\n                this.wrapper.removeChild(currentSelectedElems[i]);\r\n            }\r\n        }\r\n\r\n        // cycle through selected array, and add elements for any not represented by one\r\n        const deleteText = this.options.srDeleteText;\r\n        const fragment = document.createDocumentFragment();\r\n        const selectedClass = `${this.cssNameSpace}__selected`;\r\n        for (let i = 0, l = this.selected.length; i < l; i += 1) {\r\n            const selected = this.selected[i];\r\n            let l = current.length;\r\n            let isInDom = false;\r\n            while (l--) {\r\n                let option = current[l][SELECTED_OPTION];\r\n                if (option === selected || option.value === selected.value) {\r\n                    isInDom = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!isInDom) {\r\n                const label = selected.label;\r\n                const span = htmlToElement(\r\n                    `<span role=\"button\" class=\"${selectedClass}\" ` +\r\n                        `tabindex=\"0\" aria-label=\"${deleteText} ${label}\">` +\r\n                        `${label}</span>`\r\n                );\r\n                span[SELECTED_OPTION] = selected;\r\n                fragment.appendChild(span);\r\n            }\r\n        }\r\n        if (fragment.childNodes && fragment.childNodes.length) {\r\n            this.wrapper.insertBefore(fragment, this.list);\r\n        }\r\n\r\n        // set ids on elements\r\n        const ids = [];\r\n        // get selected elements again, as some may have been added or removed\r\n        const nowSelectedElems = this.getSelectedElems();\r\n        for (let i = 0, l = nowSelectedElems.length; i < l; i += 1) {\r\n            const id = `${this.ids.OPTION_SELECTED}-${i}`;\r\n            nowSelectedElems[i].setAttribute('id', id);\r\n            ids.push(id);\r\n        }\r\n        ids.push(this.ids.LIST);\r\n\r\n        // set input aria-owns\r\n        this.input.setAttribute('aria-owns', ids.join(' '));\r\n\r\n        // in autogrow mode, hide the placeholder if there are selected items\r\n        if (this.autoGrow && this.options.placeholder) {\r\n            const toSet = this.selected.length ? '' : this.options.placeholder;\r\n            this.input.setAttribute('placeholder', toSet);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description set the aria-describedby attribute on the input\r\n     */\r\n    setInputDescription() {\r\n        const exists = this.input.getAttribute('aria-describedby');\r\n        const current = trimString(exists || '');\r\n        let describedBy = current.replace(this.ids.SR_ASSISTANCE, '');\r\n\r\n        if (this.input.value.length === 0) {\r\n            describedBy = describedBy + ' ' + this.ids.SR_ASSISTANCE;\r\n        }\r\n\r\n        // set or remove attribute, but only if necessary\r\n        if ((describedBy = trimString(describedBy))) {\r\n            if (describedBy !== current) {\r\n                this.input.setAttribute('aria-describedby', describedBy);\r\n            }\r\n        } else if (exists) {\r\n            this.input.removeAttribute('aria-describedby');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description reset classes and aria-selected attribute for all visible filtered options\r\n     */\r\n    resetOptionAttributes() {\r\n        const cssName = this.cssNameSpace;\r\n        const nodes = this.list.childNodes;\r\n        let l = nodes.length;\r\n        while (l--) {\r\n            removeClass(nodes[l], `${cssName}__option--focused focused focus`);\r\n            nodes[l].setAttribute('aria-selected', 'false');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description move focus to correct option, or to input (on up and down arrows)\r\n     * @param {Event} event\r\n     * @param {Number} index\r\n     */\r\n    setOptionFocus(event, index) {\r\n        // set aria-selected to false and remove focused class\r\n        this.resetOptionAttributes();\r\n\r\n        // if negative index, or no options available, focus on input\r\n        const options = this.list.childNodes;\r\n        if (index < 0 || !options || !options.length) {\r\n            this.currentSelectedIndex = -1;\r\n            // focus on input, only if event was from another element\r\n            if (event && event.target !== this.input) {\r\n                this.input.focus();\r\n            }\r\n            return;\r\n        }\r\n\r\n        // down arrow on/past last option, focus on last item\r\n        if (index >= options.length) {\r\n            this.currentSelectedIndex = options.length - 1;\r\n            this.setOptionFocus(event, this.currentSelectedIndex);\r\n            return;\r\n        }\r\n\r\n        // if option found, focus...\r\n        const toFocus = options[index];\r\n        if (toFocus && typeof toFocus.getAttribute('tabindex') === 'string') {\r\n            this.currentSelectedIndex = index;\r\n            const toAdd = `${this.cssNameSpace}__option--focused focused focus`;\r\n            addClass(toFocus, toAdd);\r\n            toFocus.setAttribute('aria-selected', 'true');\r\n            toFocus.focus();\r\n            return;\r\n        }\r\n\r\n        // reset index just in case\r\n        this.currentSelectedIndex = -1;\r\n    }\r\n\r\n    /**\r\n     * @description set values and dispatch events based on any DOM elements in the selected array\r\n     */\r\n    setSourceElementValues() {\r\n        const valToSet = [];\r\n        for (let i = 0, l = this.selected.length; i < l; i += 1) {\r\n            const entry = this.selected[i];\r\n            valToSet.push(entry.value);\r\n            setElementState(entry.element, true, this); // element processing\r\n        }\r\n\r\n        // set original input value\r\n        if (this.elementIsInput) {\r\n            const valToSetString = valToSet.join(\r\n                this.options.multipleSeparator\r\n            );\r\n            if (valToSetString !== this.element.value) {\r\n                this.element.value = valToSetString;\r\n                dispatchEvent(this.element, 'change');\r\n            }\r\n        }\r\n\r\n        // included in case of multi-select mode used with a <select> element as the source\r\n        if (!this.selected.length && this.elementIsSelect) {\r\n            this.element.value = '';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description select option from the list by index\r\n     * @param {Event} event\r\n     * @param {Number} index\r\n     * @param {Boolean=} focusAfterSelection\r\n     */\r\n    handleOptionSelect(event, index, focusAfterSelection = true) {\r\n        // defensive check for proper index, that the filteredSource exists, and not exceed max items option\r\n        if (\r\n            typeof index !== 'number' ||\r\n            index < 0 ||\r\n            (this.multiple && this.selected.length >= this.options.maxItems) ||\r\n            !this.filteredSource.length ||\r\n            !this.filteredSource[index]\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        // generate new object from the selected item in case the original source gets altered\r\n        const option = mergeObjects(this.filteredSource[index]);\r\n        // detect if selected option is already in selected array\r\n        let l = this.selected.length;\r\n        let alreadySelected = false;\r\n        while (l--) {\r\n            if (this.selected[l].value === option.value) {\r\n                alreadySelected = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        this.setInputValue(this.multiple ? '' : option.label, true);\r\n        this.triggerAutoGrow();\r\n\r\n        // reset selected array in single select mode\r\n        if (!alreadySelected && !this.multiple) {\r\n            this.selected = [];\r\n        }\r\n\r\n        // (re)set values of any DOM elements based on selected array\r\n        if (!alreadySelected) {\r\n            this.selected.push(option);\r\n            this.setSourceElementValues();\r\n            this.buildMultiSelected(); // rebuild multi-selected if needed\r\n        }\r\n\r\n        this.triggerOptionCallback('onConfirm', [option]);\r\n        this.announce(`${option.label} ${this.options.srSelectedText}`, 0);\r\n\r\n        // return focus to input\r\n        if (!this.disabled && focusAfterSelection !== false) {\r\n            this.input.focus();\r\n        }\r\n\r\n        // close menu after option selection, and after returning focus to input\r\n        this.hide();\r\n    }\r\n\r\n    /**\r\n     * @description remove selected entries from results if in multiple mode\r\n     * @param {Array} results\r\n     * @returns {Array}\r\n     */\r\n    removeSelectedFromResults(results) {\r\n        if (!this.multiple || !this.selected.length) {\r\n            return results;\r\n        }\r\n        const toReturn = [];\r\n        resultsLoop: for (let i = 0, l = results.length; i < l; i += 1) {\r\n            const selected = this.selected;\r\n            const result = results[i];\r\n            for (let j = 0, k = selected.length; j < k; j += 1) {\r\n                let labelMatch = result.label === selected[j].label;\r\n                if (labelMatch && result.value === selected[j].value) {\r\n                    continue resultsLoop;\r\n                }\r\n            }\r\n            toReturn.push(result);\r\n        }\r\n        return toReturn;\r\n    }\r\n\r\n    /**\r\n     * @description final filtering and render for list options, and render\r\n     * @param {Array} results\r\n     */\r\n    setListOptions(results) {\r\n        const toShow = [];\r\n\r\n        // now commit to setting the filtered source\r\n        const mapping = this.options.sourceMapping;\r\n        // if in multiple mode, exclude items already in the selected array\r\n        const updated = this.removeSelectedFromResults(results);\r\n        // allow callback to alter the response before rendering\r\n        const callback = this.triggerOptionCallback('onResponse', updated);\r\n        this.filteredSource = callback\r\n            ? processSourceArray(callback, mapping)\r\n            : updated;\r\n\r\n        // build up the list html\r\n        const optionId = this.ids.OPTION;\r\n        const cssName = this.cssNameSpace;\r\n        const length = this.filteredSource.length;\r\n        const checkCallback = typeof this.options.onItemRender === 'function';\r\n        const maxResults = this.forceShowAll ? 9999 : this.options.maxResults;\r\n        for (let i = 0; i < length && i < maxResults; i += 1) {\r\n            const thisSource = this.filteredSource[i];\r\n            const callbackResponse =\r\n                checkCallback &&\r\n                this.triggerOptionCallback('onItemRender', [thisSource]);\r\n            const itemContent = callbackResponse || thisSource.label;\r\n            toShow.push(\r\n                `<li tabindex=\"-1\" aria-selected=\"false\" role=\"option\" class=\"${cssName}__option\" ` +\r\n                    `id=\"${optionId}--${i}\" aria-posinset=\"${i + 1}\" ` +\r\n                    `aria-setsize=\"${length}\">${itemContent}</li>`\r\n            );\r\n        }\r\n\r\n        // set has-results or no-results class on the list element\r\n        if (toShow.length) {\r\n            addClass(this.list, `${cssName}__list--has-results`);\r\n            removeClass(this.list, `${cssName}__list--no-results`);\r\n        } else {\r\n            removeClass(this.list, `${cssName}__list--has-results`);\r\n            addClass(this.list, `${cssName}__list--no-results`);\r\n        }\r\n\r\n        // no results text handling\r\n        let announce;\r\n        const noText = this.options.noResultsText;\r\n        if (!toShow.length && typeof noText === 'string' && noText.length) {\r\n            announce = noText;\r\n            let optionClass = `${cssName}__option`;\r\n            toShow.push(\r\n                `<li class=\"${optionClass} ${optionClass}--no-results\">${noText}</li>`\r\n            );\r\n        }\r\n\r\n        // remove loading class(es) and reset variables\r\n        this.cancelFilterPrep();\r\n\r\n        // announce to screen reader\r\n        if (!announce) {\r\n            announce = this.triggerOptionCallback('srResultsText', [length]);\r\n        }\r\n        this.announce(announce);\r\n\r\n        // render the list, only if we have to\r\n        // time taken for string comparison is worth it to not have to re-parse and re-render the list\r\n        const newListHtml = toShow.join('');\r\n        if (this.currentListHtml !== newListHtml) {\r\n            this.currentListHtml = newListHtml;\r\n            // innerHTML vs insertAdjacentHtml performance in old IE ?\r\n            this.list.innerHTML = newListHtml;\r\n        } else {\r\n            // if list html matches, and not re-rendered, clear aria-selected and focus classes\r\n            this.resetOptionAttributes();\r\n        }\r\n\r\n        // if toShow array is empty, make sure not to render the menu\r\n        if (!toShow.length) {\r\n            this.hide();\r\n            this.forceShowAll = false;\r\n            return;\r\n        }\r\n\r\n        this.show();\r\n        // reset forceShowAll must be after .show()\r\n        // aria-expanded attribute on showAllControl is controlled in .show() method\r\n        this.forceShowAll = false;\r\n    }\r\n\r\n    /**\r\n     * @description trigger async call for options to render\r\n     * @param {String} value\r\n     * @param {Boolean=} isFirstCall\r\n     */\r\n    handleAsync(value, isFirstCall = false) {\r\n        // abort any current call first\r\n        if (this.xhr) {\r\n            this.xhr.abort();\r\n        }\r\n\r\n        const xhr = new XMLHttpRequest();\r\n        const encode = encodeURIComponent;\r\n        const isShowAll = this.forceShowAll;\r\n        const unlimited = isShowAll || isFirstCall;\r\n        const context = isFirstCall ? null : this.api;\r\n        const baseAmount = this.multiple ? this.selected.length : 0;\r\n        const ampersandOrQuestionMark = /\\?/.test(this.source) ? '&' : '?';\r\n        let url =\r\n            this.source +\r\n            ampersandOrQuestionMark +\r\n            `${encode(this.options.asyncQueryParam)}=${encode(value)}&` +\r\n            `${encode(this.options.asyncMaxResultsParam)}=` +\r\n            `${unlimited ? 9999 : baseAmount + this.options.maxResults}`;\r\n        url = this.triggerOptionCallback('onAsyncPrep', [url], context) || url;\r\n\r\n        xhr.open('GET', url);\r\n        xhr.onload = () => {\r\n            if (xhr.readyState === xhr.DONE) {\r\n                if (xhr.status === 200) {\r\n                    // return forceShowAll to previous state before the options render\r\n                    this.forceShowAll = isShowAll;\r\n                    const callbackResponse = this.triggerOptionCallback(\r\n                        'onAsyncSuccess',\r\n                        [value, xhr],\r\n                        context\r\n                    );\r\n                    const mapping = this.options.sourceMapping;\r\n                    const source = callbackResponse || xhr.responseText;\r\n                    const items = processSourceArray(source, mapping, false);\r\n\r\n                    if (isFirstCall) {\r\n                        this.prepSelectedFromArray(items);\r\n                        this.setInputStartingStates(false);\r\n                    } else {\r\n                        this.setListOptions(items);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        // allow the creation of an uncancellable call to use on first load\r\n        if (!isFirstCall) {\r\n            this.xhr = xhr;\r\n        }\r\n\r\n        xhr.send();\r\n    }\r\n\r\n    /**\r\n     * @description trigger filtering using a value\r\n     * @param {String} value\r\n     */\r\n    filter(value) {\r\n        // fail silently if no value is provided\r\n        if (typeof value !== 'string') {\r\n            this.cancelFilterPrep();\r\n            return;\r\n        }\r\n\r\n        // allow onSearch callback to affect the searched value\r\n        // only permitted when not a forceShowAll case\r\n        let forceShowAll = this.forceShowAll;\r\n        let callbackResponse = this.triggerOptionCallback('onSearch', [value]);\r\n        if (!forceShowAll && typeof callbackResponse === 'string') {\r\n            value = callbackResponse;\r\n        }\r\n\r\n        // store search term - used for comparison in filterPrep\r\n        this.term = this.inputPollingValue = value;\r\n\r\n        // async handling\r\n        if (this.async) {\r\n            this.handleAsync(value);\r\n            // set show all to false immediately as may be used in other places\r\n            this.forceShowAll = false;\r\n            return;\r\n        }\r\n\r\n        // handle the source as a function\r\n        if (typeof this.source === 'function') {\r\n            this.source.call(this.api, this.term, response => {\r\n                let mapping = this.options.sourceMapping;\r\n                let result = processSourceArray(response, mapping);\r\n                this.setListOptions(result);\r\n            });\r\n            return;\r\n        }\r\n\r\n        // if empty string, show all\r\n        if (!value) {\r\n            forceShowAll = true;\r\n        }\r\n\r\n        // existing list handling\r\n        const toReturn = [];\r\n        if (this.source && this.source.length) {\r\n            let check = [CLEANED_LABEL];\r\n            if (!forceShowAll) {\r\n                value = cleanString(value, true);\r\n                let searchIn = this.options.alsoSearchIn;\r\n                if (Array.isArray(searchIn) && searchIn.length) {\r\n                    check = removeDuplicatesAndLabel(check.concat(searchIn));\r\n                }\r\n            }\r\n            for (let i = 0, l = this.source.length; i < l; i += 1) {\r\n                const entry = this.source[i];\r\n                if (forceShowAll || searchVarPropsFor(entry, check, value)) {\r\n                    toReturn.push(entry);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setListOptions(toReturn);\r\n    }\r\n\r\n    /**\r\n     * @description cancel filter timer and remove loading classes\r\n     */\r\n    cancelFilterPrep() {\r\n        if (this.filterTimer) {\r\n            clearTimeout(this.filterTimer);\r\n        }\r\n        const nameSpace = this.cssNameSpace;\r\n        removeClass(this.wrapper, `${nameSpace}__wrapper--loading loading`);\r\n        removeClass(this.input, `${nameSpace}__input--loading loading`);\r\n        this.filtering = false;\r\n    }\r\n\r\n    /**\r\n     * @description checks before filtering, and set filter timer\r\n     * @param {Event} e\r\n     * @param {Boolean=} doValueOverrideCheck - whether to check input value against selected item(s)\r\n     * @param {Boolean=} runNow\r\n     */\r\n    filterPrep(e, doValueOverrideCheck = false, runNow = false) {\r\n        const forceShowAll = this.forceShowAll;\r\n        const delay = forceShowAll || runNow ? 0 : this.options.delay;\r\n\r\n        // clear timers\r\n        this.cancelFilterPrep();\r\n        this.filtering = true;\r\n        this.filterTimer = setTimeout(() => {\r\n            let value = this.input.value;\r\n            // treat as empty search if...\r\n            // forceShowAll, or in single mode and selected item label matches current value\r\n            if (\r\n                forceShowAll ||\r\n                value === '' ||\r\n                (doValueOverrideCheck &&\r\n                    !this.multiple &&\r\n                    this.selected.length &&\r\n                    trimString(this.selected[0].label) === trimString(value))\r\n            ) {\r\n                value = '';\r\n            }\r\n\r\n            // handle aria-describedby\r\n            this.setInputDescription();\r\n            this.inputPollingValue = value; // set polling value, even if search criteria not met\r\n\r\n            if (!forceShowAll && value.length < this.options.minLength) {\r\n                this.hide();\r\n                return;\r\n            }\r\n\r\n            // try catch used due to permissions issues in some cases\r\n            let modifier;\r\n            try {\r\n                let keydown = e && e.type === 'keydown';\r\n                modifier = keydown && (e.altKey || e.ctrlKey || e.metaKey); // allow shift key, just in case...\r\n            } catch (e) {}\r\n\r\n            // prevent search being run again with the same value\r\n            const equalVals = value === '' ? false : value === this.term;\r\n            if (!equalVals || (equalVals && !this.menuOpen && !modifier)) {\r\n                let n = this.cssNameSpace;\r\n                addClass(this.wrapper, `${n}__wrapper--loading loading`);\r\n                addClass(this.input, `${n}__input--loading loading`);\r\n                this.currentSelectedIndex = -1;\r\n                this.filter(value);\r\n            }\r\n        }, delay);\r\n    }\r\n\r\n    /**\r\n     * @description trigger filter prep in showAll mode\r\n     * @param {Event} event\r\n     */\r\n    filterPrepShowAll(event) {\r\n        if (this.disabled) {\r\n            return;\r\n        }\r\n        // need to use a timer, as the wrapper focus out will fire after the click event\r\n        if (this.showAllPrepTimer) {\r\n            clearTimeout(this.showAllPrepTimer);\r\n        }\r\n        this.showAllPrepTimer = setTimeout(() => {\r\n            if (this.componentBlurTimer) {\r\n                clearTimeout(this.componentBlurTimer);\r\n            }\r\n            event.preventDefault();\r\n            this.forceShowAll = true;\r\n            this.filterPrep(event, false, true);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @description blur behaviour for hiding list and removing focus class(es)\r\n     * @param {Event} event\r\n     * @param {Boolean=} force - fire instantly and force blurring out of the component\r\n     */\r\n    handleComponentBlur(event, force = false) {\r\n        if (this.componentBlurTimer) {\r\n            clearTimeout(this.componentBlurTimer);\r\n        }\r\n        // use a timeout to ensure this blur fires after other focus events\r\n        // and in case the user focuses back in immediately\r\n        const delay = force ? 0 : 100;\r\n        this.componentBlurTimer = setTimeout(() => {\r\n            // do nothing if blurring to an element within the list\r\n            const activeElem = document.activeElement;\r\n            if (\r\n                !force &&\r\n                activeElem &&\r\n                !(this.showAll && this.showAll === activeElem) && // exception for show all button\r\n                !activeElem[SELECTED_OPTION] // exception for selected items\r\n            ) {\r\n                // must base this on the wrapper to allow scrolling the list in IE\r\n                if (this.wrapper.contains(activeElem)) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            // cancel any running async call\r\n            if (this.xhr) {\r\n                this.xhr.abort();\r\n            }\r\n\r\n            // confirmOnBlur behaviour\r\n            const isQueryIn = this.indexOfQueryIn.bind(this);\r\n            if (!force && this.options.confirmOnBlur && this.menuOpen) {\r\n                // if blurring from an option (currentSelectedIndex > -1), select it\r\n                let toUse = this.currentSelectedIndex;\r\n                if (typeof toUse !== 'number' || toUse === -1) {\r\n                    // otherwise check for exact match between current input value and available items\r\n                    toUse = isQueryIn(this.filteredSource);\r\n                }\r\n                this.handleOptionSelect({}, toUse, false);\r\n            }\r\n\r\n            this.cancelFilterPrep();\r\n            this.hide();\r\n\r\n            // in single select case, if current value and chosen value differ, clear selected and input value\r\n            if (!this.multiple && isQueryIn(this.selected) === -1) {\r\n                const inputOrDdl = this.elementIsInput || this.elementIsSelect;\r\n                if (inputOrDdl && this.element.value !== '') {\r\n                    this.element.value = '';\r\n                    dispatchEvent(this.element, 'change');\r\n                }\r\n                if (this.selected.length) {\r\n                    this.removeEntryFromSelected(this.selected[0]);\r\n                }\r\n                this.setInputValue('', true);\r\n            }\r\n\r\n            if (this.multiple) {\r\n                this.setInputValue('', true);\r\n            }\r\n\r\n            // trigger input resizing\r\n            this.triggerAutoGrow();\r\n\r\n            // unbind document click\r\n            if (this.documentClickBound) {\r\n                this.documentClickBound = false;\r\n                document.removeEventListener('click', this.documentClick);\r\n            }\r\n        }, delay);\r\n    }\r\n\r\n    /**\r\n     * @description enter keydown for selections\r\n     * @param {Event} event\r\n     */\r\n    handleEnterKey(event) {\r\n        // if in multiple mode, and event target was a selected item, remove it\r\n        if (this.isSelectedElem(event.target)) {\r\n            const option = event.target[SELECTED_OPTION];\r\n            return this.removeEntryFromSelected(option);\r\n        }\r\n\r\n        if (this.disabled) {\r\n            return;\r\n        }\r\n\r\n        if (this.showAll && event.target === this.showAll) {\r\n            this.filterPrepShowAll(event);\r\n            return;\r\n        }\r\n\r\n        if (this.menuOpen) {\r\n            event.preventDefault();\r\n            if (this.currentSelectedIndex > -1) {\r\n                this.handleOptionSelect(event, this.currentSelectedIndex);\r\n            }\r\n        }\r\n\r\n        // if enter keypress was from the filter input, trigger search immediately\r\n        if (event.target === this.input) {\r\n            this.filterPrep(event, false, true);\r\n        }\r\n    }\r\n    /**\r\n     * @description down arrow usage - option focus, or search all\r\n     * @param {Event} event\r\n     */\r\n    handleDownArrowKey(event) {\r\n        event.preventDefault();\r\n        // if closed, and text is long enough, run search\r\n        if (!this.menuOpen) {\r\n            this.forceShowAll = this.options.minLength < 1;\r\n            if (\r\n                this.forceShowAll ||\r\n                this.input.value.length >= this.options.minLength\r\n            ) {\r\n                this.filterPrep(event);\r\n            }\r\n        }\r\n        // move focus to downward option\r\n        if (this.menuOpen && !this.filtering) {\r\n            const current = this.currentSelectedIndex;\r\n            if (typeof current !== 'number' || current < 0) {\r\n                this.setOptionFocus(event, 0);\r\n            } else {\r\n                this.setOptionFocus(event, current + 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description up arrow usage - option focus, or return focus to input\r\n     * @param {Event} event\r\n     */\r\n    handleUpArrowKey(event) {\r\n        event.preventDefault();\r\n        const usable = !this.disabled && this.menuOpen;\r\n        if (usable && typeof this.currentSelectedIndex === 'number') {\r\n            this.setOptionFocus(event, this.currentSelectedIndex - 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description standard keydown handling (excluding enter, up, down, escape)\r\n     * @param {Event} event\r\n     */\r\n    handleKeyDownDefault(event) {\r\n        const targetIsInput = event.target === this.input;\r\n        // on space, if focus state is on any other item, treat as enter\r\n        if (event.keyCode === 32 && !targetIsInput) {\r\n            event.preventDefault();\r\n            return this.handleEnterKey(event);\r\n        }\r\n\r\n        if (this.disabled) {\r\n            return;\r\n        }\r\n\r\n        // on backspace, if using empty input in multiple mode, delete last selected entry\r\n        const selectedLength = this.selected && this.selected.length;\r\n        if (\r\n            this.options.deleteOnBackspace &&\r\n            this.input.value === '' &&\r\n            event.keyCode === 8 &&\r\n            selectedLength &&\r\n            targetIsInput &&\r\n            this.multiple\r\n        ) {\r\n            this.removeEntryFromSelected(this.selected[selectedLength - 1]);\r\n            return;\r\n        }\r\n\r\n        // any printable character not on input, return focus to input\r\n        const printableKey = isPrintableKey(event.keyCode);\r\n        const focusInput = !targetIsInput && printableKey;\r\n        if (focusInput) {\r\n            this.input.focus();\r\n        }\r\n\r\n        // trigger filtering - done here, instead of using input event, due to IE9 issues\r\n        if (focusInput || (targetIsInput && printableKey)) {\r\n            this.filterPrep(event);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description component keydown handling\r\n     * @param {Event} event\r\n     */\r\n    prepKeyDown(event) {\r\n        switch (event.keyCode) {\r\n            case 13: // on enter\r\n                this.handleEnterKey(event);\r\n                break;\r\n            case 27: // on escape\r\n                this.handleComponentBlur(event, true);\r\n                break;\r\n            case 38: // on up\r\n                this.handleUpArrowKey(event);\r\n                break;\r\n            case 40: // on down\r\n                this.handleDownArrowKey(event);\r\n                break;\r\n            default:\r\n                this.handleKeyDownDefault(event);\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description cancel checking for input value changes from external causes\r\n     */\r\n    cancelPolling() {\r\n        if (this.pollingTimer) {\r\n            clearTimeout(this.pollingTimer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description start checking for input value changes from causes that bypass event detection\r\n     */\r\n    startPolling() {\r\n        // check if input value does not equal last searched term\r\n        if (!this.filtering && this.input.value !== this.inputPollingValue) {\r\n            this.filterPrep({});\r\n        }\r\n        this.pollingTimer = setTimeout(() => {\r\n            this.startPolling();\r\n        }, 200);\r\n    }\r\n\r\n    /**\r\n     * @description bind component events to generated elements\r\n     */\r\n    bindEvents() {\r\n        // when focus is moved outside of the component, close everything\r\n        this.wrapper.addEventListener('focusout', event => {\r\n            this.handleComponentBlur(event, false);\r\n        });\r\n        // reset selected index\r\n        this.wrapper.addEventListener('focusin', event => {\r\n            if (!this.list.contains(event.target)) {\r\n                this.currentSelectedIndex = -1;\r\n            }\r\n        });\r\n        // handle all keydown events inside the component\r\n        this.wrapper.addEventListener('keydown', event => {\r\n            this.prepKeyDown(event);\r\n        });\r\n        // if clicking directly on the wrapper, move focus to the input\r\n        this.wrapper.addEventListener('click', event => {\r\n            if (event.target === this.wrapper) {\r\n                this.input.focus();\r\n                return;\r\n            }\r\n            if (this.isSelectedElem(event.target)) {\r\n                const option = event.target[SELECTED_OPTION];\r\n                this.removeEntryFromSelected(option);\r\n            }\r\n        });\r\n\r\n        const wrapperFocusClasses = `${this.cssNameSpace}__wrapper--focused focused focus`;\r\n        const inputFocusClasses = `${this.cssNameSpace}__input--focused focused focus`;\r\n        // when blurring out of input, remove classes\r\n        this.input.addEventListener('blur', () => {\r\n            removeClass(this.wrapper, wrapperFocusClasses);\r\n            removeClass(this.input, inputFocusClasses);\r\n            this.cancelPolling();\r\n        });\r\n        // trigger filter on input event as well as keydown (covering bases)\r\n        this.input.addEventListener('input', event => {\r\n            this.filterPrep(event);\r\n        });\r\n        // when specifically clicking on input, if menu is closed, and value is long enough, search\r\n        this.input.addEventListener('click', event => {\r\n            const open = this.menuOpen;\r\n            if (!open && this.input.value.length >= this.options.minLength) {\r\n                this.filterPrep(event, true);\r\n            }\r\n        });\r\n        // when focusing on input, reset selected index and trigger search handling\r\n        this.input.addEventListener('focusin', () => {\r\n            addClass(this.wrapper, wrapperFocusClasses);\r\n            addClass(this.input, inputFocusClasses);\r\n            this.startPolling();\r\n            if (!this.disabled && !this.menuOpen) {\r\n                this.filterPrep(event, true);\r\n            }\r\n        });\r\n\r\n        // show all button click\r\n        if (this.showAll) {\r\n            this.showAll.addEventListener('click', event => {\r\n                this.filterPrepShowAll(event);\r\n            });\r\n        }\r\n\r\n        // clear any current focus position when hovering into the list\r\n        this.list.addEventListener('mouseenter', event => {\r\n            this.resetOptionAttributes();\r\n        });\r\n        // trigger options selection\r\n        this.list.addEventListener('click', event => {\r\n            if (event.target !== this.list) {\r\n                const childNodes = this.list.childNodes;\r\n                if (childNodes.length) {\r\n                    const nodeIndex = [].indexOf.call(childNodes, event.target);\r\n                    this.handleOptionSelect(event, nodeIndex);\r\n                }\r\n            }\r\n        });\r\n\r\n        // setup input autogrow behaviour\r\n        if (this.autoGrow) {\r\n            this.AutoGrowInput = new AutoGrow(this.input);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description set starting source array based on child checkboxes\r\n     */\r\n    prepListSourceCheckboxes() {\r\n        this.multiple = true; // force multiple in this case\r\n        // reset source and use checkboxes\r\n        this.source = [];\r\n        const elements = this.element.querySelectorAll(\r\n            'input[type=\"checkbox\"]'\r\n        );\r\n        for (let i = 0, l = elements.length; i < l; i += 1) {\r\n            const checkbox = elements[i];\r\n            // must have a value other than empty string\r\n            if (!checkbox.value) {\r\n                continue;\r\n            }\r\n            const toPush = { element: checkbox, value: checkbox.value };\r\n            // label searching\r\n            let label = checkbox.closest('label');\r\n            if (!label && checkbox.id) {\r\n                label = document.querySelector('[for=\"' + checkbox.id + '\"]');\r\n            }\r\n            if (label) {\r\n                toPush.label = label.textContent;\r\n            }\r\n            // if no label so far, re-use value\r\n            if (!toPush.label) {\r\n                toPush.label = toPush.value;\r\n            }\r\n            toPush[CLEANED_LABEL] = cleanString(toPush.label);\r\n            this.source.push(toPush);\r\n            // add to selected if applicable\r\n            if (checkbox.checked) {\r\n                this.selected.push(toPush);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description set starting source array based on <select> options\r\n     */\r\n    prepListSourceDdl() {\r\n        this.multiple = this.element.multiple; // force multiple to match select\r\n        // reset source and use options\r\n        this.source = [];\r\n        const options = this.element.querySelectorAll('option');\r\n        for (let i = 0, l = options.length; i < l; i += 1) {\r\n            const option = options[i];\r\n            // must have a value other than empty string\r\n            if (!option.value) {\r\n                continue;\r\n            }\r\n            const toPush = {\r\n                element: option,\r\n                value: option.value,\r\n                label: option.textContent\r\n            };\r\n            toPush[CLEANED_LABEL] = cleanString(toPush.label);\r\n            this.source.push(toPush);\r\n            // add to selected if applicable\r\n            if (option.selected) {\r\n                this.selected.push(toPush);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description build up selected array if starting element was an input, and had a value\r\n     * @param {Object[]} source\r\n     */\r\n    prepSelectedFromArray(source) {\r\n        const value = this.elementIsInput && this.element.value;\r\n        if (value && source && source.length) {\r\n            // account for multiple mode\r\n            const multiple = this.options.multiple;\r\n            const separator = this.options.multipleSeparator;\r\n            const valueArr = multiple ? value.split(separator) : [value];\r\n\r\n            for (let i = 0, l = valueArr.length; i < l; i += 1) {\r\n                const val = valueArr[i];\r\n                const isQueryIn = this.indexOfQueryIn;\r\n                // make sure it is not already in the selected array\r\n                const isSelected = isQueryIn(this.selected, val, 'value') > -1;\r\n\r\n                // but is in the source array (check via 'value', not 'label')\r\n                if (!isSelected) {\r\n                    const indexInSource = isQueryIn(source, val, 'value');\r\n                    if (indexInSource > -1) {\r\n                        this.selected.push(source[indexInSource]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description adjust starting source array to format needed, and set selected\r\n     */\r\n    prepListSourceArray() {\r\n        const mapping = this.options.sourceMapping;\r\n        this.source = processSourceArray(this.source, mapping);\r\n        this.prepSelectedFromArray(this.source);\r\n    }\r\n\r\n    /**\r\n     * @description trigger source string endpoint to generate selected array\r\n     */\r\n    prepListSourceAsync() {\r\n        this.async = true;\r\n        if (this.elementIsInput && this.element.value) {\r\n            this.handleAsync(this.element.value, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description process source function to generate selected array\r\n     */\r\n    prepListSourceFunction() {\r\n        if (this.elementIsInput && this.element.value) {\r\n            this.source.call(undefined, this.element.value, response => {\r\n                this.prepSelectedFromArray(\r\n                    processSourceArray(response, this.options.sourceMapping)\r\n                );\r\n                this.setInputStartingStates(false);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description adjust set sources to needed format\r\n     */\r\n    prepListSource() {\r\n        // allow complete control over the source handling via custom function\r\n        if (typeof this.source === 'function') {\r\n            return this.prepListSourceFunction();\r\n        }\r\n\r\n        // string source - treat as async endpoint\r\n        if (typeof this.source === 'string' && this.source.length) {\r\n            return this.prepListSourceAsync();\r\n        }\r\n\r\n        // array source - copy array\r\n        if (Array.isArray(this.source) && this.source.length) {\r\n            return this.prepListSourceArray();\r\n        }\r\n\r\n        // dropdown source\r\n        if (this.elementIsSelect) {\r\n            return this.prepListSourceDdl();\r\n        }\r\n\r\n        // checkboxlist source\r\n        if (this.element.querySelector('input[type=\"checkbox\"]')) {\r\n            this.prepListSourceCheckboxes();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description set input starting states - aria attributes, disabled state, starting value\r\n     * @param {Boolean=} setAriaAttrs\r\n     */\r\n    setInputStartingStates(setAriaAttrs = true) {\r\n        if (setAriaAttrs) {\r\n            // update corresponding label to now focus on the new input\r\n            if (this.ids.ELEMENT) {\r\n                const label = document.querySelector(\r\n                    '[for=\"' + this.ids.ELEMENT + '\"]'\r\n                );\r\n                if (label) {\r\n                    label.ariaAutocompleteOriginalFor = this.ids.ELEMENT;\r\n                    label.setAttribute('for', this.ids.INPUT);\r\n                }\r\n            }\r\n\r\n            // update aria-describedby and aria-labelledby attributes if present\r\n            const describedBy = this.element.getAttribute('aria-describedby');\r\n            if (describedBy) {\r\n                this.input.setAttribute('aria-describedby', describedBy);\r\n            }\r\n            const labelledBy = this.element.getAttribute('aria-labelledby');\r\n            if (labelledBy) {\r\n                this.input.setAttribute('aria-labelledby', labelledBy);\r\n            }\r\n        }\r\n\r\n        // if selected item(s) already exists\r\n        if (this.selected.length) {\r\n            // for multi select variant, set selected items\r\n            if (this.multiple) {\r\n                this.buildMultiSelected();\r\n            }\r\n            // for single select variant, set value to match\r\n            else {\r\n                this.setInputValue(this.selected[0].label || '', true);\r\n                this.triggerAutoGrow();\r\n            }\r\n        }\r\n\r\n        // setup input description - done here in case value is affected above\r\n        this.setInputDescription();\r\n\r\n        // disable the control if the invoked element was disabled\r\n        if (!!this.element.disabled) {\r\n            this.disable();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description build and insert component html structure\r\n     */\r\n    setHtml() {\r\n        const o = this.options;\r\n        const cssName = this.cssNameSpace;\r\n        const wrapperClass = o.wrapperClassName ? ` ${o.wrapperClassName}` : '';\r\n        const newHtml = [\r\n            `<div id=\"${this.ids.WRAPPER}\" class=\"${cssName}__wrapper${wrapperClass}\">`\r\n        ];\r\n\r\n        // add input\r\n        const name = o.name ? ` ${o.name}` : ``;\r\n        const inputClass = o.inputClassName ? ` ${o.inputClassName}` : '';\r\n        newHtml.push(\r\n            `<input type=\"text\" autocomplete=\"off\" aria-expanded=\"false\" aria-autocomplete=\"list\" ` +\r\n                `role=\"combobox\" id=\"${this.ids.INPUT}\" placeholder=\"${o.placeholder}\" ` +\r\n                `aria-owns=\"${this.ids.LIST}\" aria-placeholder=\"${o.placeholder}\" ` +\r\n                `class=\"${cssName}__input${inputClass}\"${name} />`\r\n        );\r\n\r\n        // button to show all available options\r\n        if (o.showAllControl) {\r\n            newHtml.push(\r\n                `<span role=\"button\" aria-label=\"${o.srShowAllText}\" class=\"${cssName}__show-all\" ` +\r\n                    `tabindex=\"0\" id=\"${this.ids.BUTTON}\" aria-expanded=\"false\"></span>`\r\n            );\r\n        }\r\n        // add the list holder\r\n        const explainerText = o.srListLabelText;\r\n        const listClass = o.listClassName ? ` ${o.listClassName}` : '';\r\n        const explainer = explainerText ? ` aria-label=\"${explainerText}\"` : '';\r\n        newHtml.push(\r\n            `<ul id=\"${this.ids.LIST}\" class=\"${cssName}__list${listClass}\" role=\"listbox\" ` +\r\n                `hidden=\"hidden\"${explainer}></ul>`\r\n        );\r\n        // add the screen reader assistance element\r\n        newHtml.push(\r\n            `<span class=\"sr-only ${cssName}__sr-only ${cssName}__sr-assistance\" ` +\r\n                `id=\"${this.ids.SR_ASSISTANCE}\">${o.srAssistiveText}</span>`\r\n        );\r\n        // add element for added screen reader announcements\r\n        newHtml.push(\r\n            `<span class=\"sr-only ${cssName}__sr-only ${cssName}__sr-announcements\" ` +\r\n                `id=\"${this.ids.SR_ANNOUNCEMENTS}\" aria-live=\"polite\" aria-atomic=\"true\"></span>`\r\n        );\r\n\r\n        // close all and append\r\n        newHtml.push(`</div>`);\r\n        this.element.insertAdjacentHTML('afterend', newHtml.join(''));\r\n    }\r\n\r\n    /**\r\n     * @description generate api object to expose on the element\r\n     */\r\n    generateApi() {\r\n        this.api = {\r\n            open: () => this.show.call(this),\r\n            close: () => this.hide.call(this),\r\n            filter: val => this.filter.call(val)\r\n        };\r\n\r\n        const a = [\r\n            'options',\r\n            'destroy',\r\n            'enable',\r\n            'disable',\r\n            'input',\r\n            'wrapper',\r\n            'list',\r\n            'selected'\r\n        ];\r\n\r\n        for (let i = 0, l = a.length; i < l; i += 1) {\r\n            this.api[a[i]] =\r\n                typeof this[a[i]] === 'function'\r\n                    ? () => this[a[i]].call(this)\r\n                    : this[a[i]];\r\n        }\r\n\r\n        // store api on original element\r\n        this.element.ariaAutocomplete = this.api;\r\n    }\r\n\r\n    /**\r\n     * @description destroy component\r\n     */\r\n    destroy() {\r\n        // return original label 'for' attribute back to element id\r\n        const label = document.querySelector('[for=\"' + this.ids.INPUT + '\"]');\r\n        if (label && label.ariaAutocompleteOriginalFor) {\r\n            label.setAttribute('for', label.ariaAutocompleteOriginalFor);\r\n            delete label.ariaAutocompleteOriginalFor;\r\n        }\r\n        // remove the document click if still bound\r\n        if (this.documentClickBound) {\r\n            document.removeEventListener('click', this.documentClick);\r\n        }\r\n        // destroy autogrow behaviour and events\r\n        if (this.autoGrow && this.AutoGrowInput) {\r\n            this.AutoGrowInput.destroy();\r\n        }\r\n        // remove the whole wrapper\r\n        this.element.parentNode.removeChild(this.wrapper);\r\n        delete this.element.ariaAutocomplete;\r\n        // re-show original element\r\n        this.show(this.element);\r\n        // set all instance properties to null to clean up DOMNode references\r\n        for (let i in this) {\r\n            if (this.hasOwnProperty(i)) {\r\n                this[i] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description initialise AriaAutocomplete\r\n     * @param {Element} element\r\n     * @param {Object=} options\r\n     */\r\n    init(element, options) {\r\n        // ids used for DOM queries and accessibility attributes e.g. aria-controls\r\n        appIndex += 1;\r\n        this.ids = {};\r\n        this.ids.ELEMENT = element.id;\r\n        this.ids.PREFIX = `${element.id || ''}aria-autocomplete-${appIndex}`;\r\n        this.ids.LIST = `${this.ids.PREFIX}-list`;\r\n        this.ids.INPUT = `${this.ids.PREFIX}-input`;\r\n        this.ids.BUTTON = `${this.ids.PREFIX}-button`;\r\n        this.ids.OPTION = `${this.ids.PREFIX}-option`;\r\n        this.ids.WRAPPER = `${this.ids.PREFIX}-wrapper`;\r\n        this.ids.OPTION_SELECTED = `${this.ids.OPTION}-selected`;\r\n        this.ids.SR_ASSISTANCE = `${this.ids.PREFIX}-sr-assistance`;\r\n        this.ids.SR_ANNOUNCEMENTS = `${this.ids.PREFIX}-sr-announcements`;\r\n\r\n        this.selected = [];\r\n        this.element = element;\r\n        this.elementIsInput = element.nodeName === 'INPUT';\r\n        this.elementIsSelect = element.nodeName === 'SELECT';\r\n        this.options = mergeObjects(DEFAULT_OPTIONS, options);\r\n\r\n        // set these internally so that the component has to be properly destroyed to change them\r\n        this.source = this.options.source;\r\n        this.multiple = this.options.multiple;\r\n        this.autoGrow = this.options.autoGrow;\r\n        this.cssNameSpace = this.options.cssNameSpace;\r\n        this.documentClick = this.handleComponentBlur.bind(this);\r\n\r\n        // create html structure\r\n        this.setHtml();\r\n\r\n        // additional app variables\r\n        this.list = document.getElementById(this.ids.LIST);\r\n        this.input = document.getElementById(this.ids.INPUT);\r\n        this.wrapper = document.getElementById(this.ids.WRAPPER);\r\n        this.showAll = document.getElementById(this.ids.BUTTON);\r\n        this.srAnnouncements = document.getElementById(\r\n            this.ids.SR_ANNOUNCEMENTS\r\n        );\r\n\r\n        // set internal source array, from static elements if necessary\r\n        this.prepListSource();\r\n\r\n        // set any further classes on component wrapper based on options\r\n        let wrapperClass = '';\r\n        if (this.options.showAllControl) {\r\n            wrapperClass += ` ${this.cssNameSpace}__wrapper--show-all`;\r\n        }\r\n        if (this.autoGrow) {\r\n            wrapperClass += ` ${this.cssNameSpace}__wrapper--autogrow`;\r\n        }\r\n        if (this.multiple) {\r\n            wrapperClass += ` ${this.cssNameSpace}__wrapper--multiple`;\r\n        }\r\n        if (wrapperClass) {\r\n            addClass(this.wrapper, wrapperClass);\r\n        }\r\n\r\n        // hide element and list manually\r\n        this.hide(this.list); // pass in the list so that the onClose is not triggered\r\n        this.hide(this.element);\r\n\r\n        // generate api object to expose\r\n        this.generateApi();\r\n\r\n        // set starting states for input - must be after source has been defined\r\n        this.setInputStartingStates();\r\n\r\n        // bind all necessary events\r\n        this.bindEvents();\r\n\r\n        // fire onready callback\r\n        this.triggerOptionCallback('onReady', [this.wrapper]);\r\n    }\r\n}\r\n\r\n/**\r\n * @description expose specific function rather than the AriaAutocomplete class\r\n * @param {Element} elem\r\n * @param {Object} options\r\n * @returns {Object}\r\n */\r\nwindow['AriaAutocomplete'] = (elem, options) => {\r\n    return new AriaAutocomplete(elem, options).api;\r\n};\r\n\r\nexport default (elem, options) => {\r\n    return new AriaAutocomplete(elem, options).api;\r\n};\r\n"]}