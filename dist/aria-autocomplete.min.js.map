{"version":3,"sources":["closest-polyfill.js","helpers.js","aria-autocomplete.js"],"names":["Element","prototype","matches","msMatchesSelector","webkitMatchesSelector","closest","s","el","parentElement","parentNode","nodeType","trimString","theString","trim","hasClass","element","className","e","cur","getAttribute","indexOf","addClass","classes","currentValue","current","finalValue","i","cs","split","l","length","setAttribute","removeClass","replace","REGEX_AMPERSAND","REGEX_DUPE_WHITESPACE","REGEX_MAKE_SAFE","REGEX_TO_IGNORE","cleanString","toLowerCase","isPrintableKey","keyCode","mergeObjects","n","o","p","hasOwnProperty","dispatchEvent","event","document","createEvent","initEvent","fireEvent","setElementState","selected","instance","nodeName","checked","elementChangeEventTimer","clearTimeout","setTimeout","processSourceArray","sourceArray","mapping","setCleanedLabel","toReturn","mapValue","mapLabel","result","entry","value","label","toString","cleanedLabel","push","DIV","createElement","htmlToElement","html","innerHTML","firstChild","appIndex","DEFAULT_OPTIONS","name","source","sourceMapping","delay","minLength","maxResults","showAllControl","confirmOnBlur","multiple","autoGrow","maxItems","multipleSeparator","deleteOnBackspace","asyncQueryParam","asyncMaxResultsParam","placeholder","noResultsText","cssNameSpace","listClassName","inputClassName","wrapperClassName","srDeleteText","srDeletedText","srShowAllText","srSelectedText","srListLabelText","srAssistiveText","srResultsText","onAsyncPrep","undefined","onAsyncSuccess","onResponse","onSearch","onConfirm","onDelete","onReady","onClose","onOpen","AriaAutocomplete","options","ariaAutocomplete","ids","ELEMENT","id","PREFIX","LIST","INPUT","BUTTON","OPTION","WRAPPER","OPTION_SELECTED","SR_ASSISTANCE","SR_ANNOUNCEMENTS","elementIsInput","elementIsSelect","list","input","wrapper","showAll","srAnnouncements","xhr","term","async","menuOpen","disabled","filtering","forceShowAll","filteredSource","currentListHtml","inputPollingValue","currentSelectedIndex","documentClick","documentClickBound","filterTimer","pollingTimer","announcementTimer","componentBlurTimer","init","args","context","api","apply","toRemove","removeAttribute","expanded","show","triggerOptionCallback","addEventListener","hide","query","prop","text","textContent","ariaAutocompleteSelectedOption","childNodes","a","isSelectedElem","index","option","splice","buildMultiSelected","announce","currentSelectedElems","getSelectedElems","isInSelected","removeChild","deleteText","fragment","createDocumentFragment","selectedClass","isInDom","span","appendChild","insertBefore","join","toSet","exists","describedBy","cssName","nodes","resetOptionAttributes","target","focus","setOptionFocus","toFocus","toAdd","valToSet","valToSetString","disable","enable","focusAfterSelection","alreadySelected","setSourceElementValues","results","resultsLoop","j","k","labelMatch","toShow","optionId","updated","removeSelectedFromResults","callback","noText","optionClass","cancelFilterPrep","newListHtml","isFirstCall","XMLHttpRequest","encode","encodeURIComponent","isShowAll","unlimited","baseAmount","ampersandOrQuestionMark","test","url","abort","open","onload","readyState","DONE","status","callbackResponse","responseText","items","prepSelectedFromArray","setListOptions","send","handleAsync","search","staticSourceIndex","call","response","nameSpace","doValueOverrideCheck","runNow","setInputDescription","modifier","type","altKey","ctrlKey","metaKey","equalVals","filter","preventDefault","filterPrep","force","activeElem","activeElement","contains","isQueryIn","isQueryContainedIn","bind","toUse","handleOptionSelect","removeEntryFromSelected","removeEventListener","filterPrepShowAll","targetIsInput","handleEnterKey","selectedLength","focusInput","handleComponentBlur","handleUpArrowKey","handleDownArrowKey","handleKeyDownDefault","startPolling","prepKeyDown","cancelPolling","nodeIndex","elements","querySelectorAll","checkbox","toPush","querySelector","separator","valueArr","val","indexInSource","prepListSourceFunction","prepListSourceAsync","Array","isArray","prepListSourceArray","prepListSourceDdl","prepListSourceCheckboxes","ariaAutocompleteOriginalFor","labelledBy","explainerText","listClass","inputClass","wrapperClass","explainer","newHtml","insertAdjacentHTML","close","destroy","isRefresh","destroyCheck","setHtml","getElementById","prepListSource","generateApi","setInputStartingStates","bindEvents","window","elem"],"mappings":"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","file":"aria-autocomplete.min.js","sourceRoot":"../src","sourcesContent":["if (!Element.prototype.matches) {\n    Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n}\nif (!Element.prototype.closest) {\n    Element.prototype.closest = function (s) {\n        var el = this;\n        do { \n            if (el.matches(s)) { \n                return el; \n            } \n            el = el.parentElement || el.parentNode; \n        } while (el !== null && el.nodeType === 1);\n        return null;\n    };\n}","/**\n * @description trim string helper\n * @param {string} theString\n */\nexport function trimString(theString) {\n    return theString == null ? '' : (theString + '').trim();\n}\n\n/**\n * @description check if element has class\n * @param {Element} element - element to check class on\n * @param {String} className\n * @returns {Boolean}\n */\nexport function hasClass(element, className) {\n    let e = element;\n    let cur = trimString(e.getAttribute && e.getAttribute('class'));\n    return ` ${cur} `.indexOf(` ${className} `) > -1;\n}\n\n/**\n * @description add class(es) to element\n * @param {Element} element - element to add class(es) to\n * @param {String} classes - space delimitted class(es) to add\n */\nexport function addClass(element, classes) {\n    let currentValue = trimString(\n        element.getAttribute && element.getAttribute('class')\n    );\n    let current = ' ' + currentValue + ' ';\n    let finalValue = '';\n\n    for (let i = 0, cs = classes.split(' '), l = cs.length; i < l; i += 1) {\n        if (cs[i] !== '' && current.indexOf(' ' + cs[i] + ' ') === -1) {\n            finalValue += ' ' + cs[i];\n        }\n    }\n    if (currentValue !== (finalValue = trimString(currentValue + finalValue))) {\n        element.setAttribute('class', finalValue);\n    }\n}\n\n/**\n * @description remove class(es) from element\n * @param {Element} element - element to add class(es) to\n * @param {String} classes - space delimitted class(es) to remove\n */\nexport function removeClass(element, classes) {\n    let currentValue = trimString(\n        element.getAttribute && element.getAttribute('class')\n    );\n    let finalValue = ' ' + currentValue + ' ';\n\n    for (let i = 0, cs = classes.split(' '), l = cs.length; i < l; i += 1) {\n        finalValue = finalValue.replace(' ' + cs[i] + ' ', ' ');\n    }\n    if (currentValue !== (finalValue = trimString(finalValue))) {\n        element.setAttribute('class', finalValue);\n    }\n}\n\n// regex constants used for string cleaning\nconst REGEX_AMPERSAND = /&/g;\nconst REGEX_DUPE_WHITESPACE = /\\s\\s+/g;\nconst REGEX_MAKE_SAFE = /[.*+?^${}()|[\\]\\\\]/g;\nconst REGEX_TO_IGNORE = /[\\u2018\\u2019',:\\u2013-]/g;\n/**\n * @description clean string of some characters, and make safe for regex searching\n * @param {String} theString\n * @returns {String}\n */\nexport function cleanString(theString) {\n    theString = theString.replace(REGEX_TO_IGNORE, ''); // ignore quotes, commas, colons, and hyphens\n    theString = theString.replace(REGEX_AMPERSAND, 'and'); // treat & and 'and' as the same\n    theString = theString.replace(REGEX_MAKE_SAFE, '\\\\$&'); // make safe for regex searching\n    theString = theString.replace(REGEX_DUPE_WHITESPACE, ' '); // ignore duplicate whitespace\n    return trimString(theString.toLowerCase()); // case insensitive\n}\n\n/**\n * @description check if keycode is for a printable/width-affecting character\n * @param {Number} keyCode\n * @returns {Boolean}\n */\nexport function isPrintableKey(keyCode) {\n    return (\n        (keyCode >= 48 && keyCode <= 57) || // 0-9\n        (keyCode >= 65 && keyCode <= 90) || // a-z\n        (keyCode >= 96 && keyCode <= 111) || // numpad 0-9, numeric operators\n        (keyCode >= 186 && keyCode <= 222) || // semicolon, equal, comma, dash, etc.\n        keyCode === 32 || // space\n        keyCode === 8 || // backspace\n        keyCode === 46 // delete\n    );\n}\n\n/**\n * @description merge objects together to generate a new one\n * @param {Object} args - objects to merge together\n * @returns {Object}\n */\nexport function mergeObjects(...args) {\n    let n = {};\n    for (let i = 0, l = args.length; i < l; i += 1) {\n        let o = args[i];\n        for (let p in o) {\n            if (o.hasOwnProperty(p) && typeof o[p] !== 'undefined') {\n                n[p] = o[p];\n            }\n        }\n    }\n    return n;\n}\n\n/**\n * @description dispatch event helper\n * @param {Element} element\n * @param {String} event\n */\nexport function dispatchEvent(element, event) {\n    if ('createEvent' in document) {\n        let e = document.createEvent('HTMLEvents');\n        e.initEvent(event, true, true);\n        element.dispatchEvent(e);\n    } else {\n        element.fireEvent('on' + event);\n    }\n}\n\n/**\n * @description set element option or checkbox to specified state and trigger change event\n * @param {Element} element\n * @param {Boolean} selected\n * @param {(AriaAutocomplete|Object)} instance\n */\nexport function setElementState(element, selected, instance) {\n    selected = !!selected;\n    if (element) {\n        // handle checkbox\n        if (\n            element.nodeName === 'INPUT' &&\n            typeof element.checked === 'boolean' &&\n            element.checked !== selected\n        ) {\n            element.checked = selected;\n            dispatchEvent(element, 'change');\n        }\n\n        // handle dropdown option\n        if (element.nodeName === 'OPTION' && element.selected !== selected) {\n            element.selected = selected;\n            // ensure change event only fires once for dropdown\n            if (instance.elementChangeEventTimer) {\n                clearTimeout(instance.elementChangeEventTimer);\n            }\n            instance.elementChangeEventTimer = setTimeout(function() {\n                dispatchEvent(element.closest('select'), 'change');\n            }, 1);\n        }\n    }\n}\n\n/**\n * @description process an array of strings or objects to ensure needed props exist\n * @param {(String|Object)[]} sourceArray\n * @param {Object=} mapping - value and label mapping used in object cases\n * @param {Boolean=} setCleanedLabel - defaults to true\n * @returns {Array}\n */\nexport function processSourceArray(sourceArray, mapping = {}, setCleanedLabel) {\n    let toReturn = [];\n    let mapValue = mapping['value'];\n    let mapLabel = mapping['label'];\n    for (let i = 0, l = sourceArray.length; i < l; i += 1) {\n        let result = {};\n        let entry = sourceArray[i];\n        // handle array of strings\n        if (typeof entry === 'string') {\n            result.value = result.label = entry;\n        }\n        // handle array of objects - ensure value and label exist, and maintain any other properties\n        else {\n            result = entry;\n            let value = result[mapValue] || result.value || result.label;\n            let label = result[mapLabel] || result.label || result.value;\n            result.value = (value || '').toString();\n            result.label = (label || '').toString();\n        }\n        // whether to set a cleaned label for static source filtering (in filter method)\n        if (setCleanedLabel !== false) {\n            result.cleanedLabel = cleanString(result.label);\n        }\n        toReturn.push(result);\n    }\n    return toReturn;\n}\n\nconst DIV = document.createElement('div');\n/**\n * @description convert HTML string into an element\n * @param {String} html\n * @returns {Element}\n */\nexport function htmlToElement(html) {\n    DIV.innerHTML = trimString(html);\n    return DIV.firstChild;\n}\n","import './closest-polyfill';\r\nimport {\r\n    trimString,\r\n    hasClass,\r\n    addClass,\r\n    removeClass,\r\n    cleanString,\r\n    isPrintableKey,\r\n    mergeObjects,\r\n    dispatchEvent,\r\n    setElementState,\r\n    processSourceArray,\r\n    htmlToElement\r\n} from './helpers';\r\n\r\nlet appIndex = 0;\r\n\r\nconst DEFAULT_OPTIONS = {\r\n    /**\r\n     * @description Give the autocomplete a name to be included in form submissions\r\n     * (Instead of using this option, I would advise initialising the autocomplete\r\n     * on an existing input that will be submitted; this approach is compatible\r\n     * with the control in multiple mode)\r\n     */\r\n    name: '',\r\n    /**\r\n     * @type {String | String[] | Object[] | Function}\r\n     * @description Specify source. See examples file for more specific usage.\r\n     * @example ['Afghanistan', 'Albania', 'Algeria', ...more]\r\n     * @example (query, render) => render(arrayToUse)\r\n     */\r\n    source: '',\r\n    /**\r\n     * @description Properties to use for label and value\r\n     * when source is an Array of Objects\r\n     */\r\n    sourceMapping: {},\r\n\r\n    /**\r\n     * @description Input delay after typing before running a search\r\n     */\r\n    delay: 100,\r\n    /**\r\n     * @description Minimum number of characters to run a search (includes spaces)\r\n     */\r\n    minLength: 1,\r\n    /**\r\n     * @description Maximum number of results to render. Also used with async endpoint\r\n     */\r\n    maxResults: 9999,\r\n    /**\r\n     * @description Render a control that triggers showing all options.\r\n     * Runs a search with an empty query: '', and maxResults of 9999\r\n     */\r\n    showAllControl: false,\r\n    /**\r\n     * Confirm currently active selection when blurring off of the control. If\r\n     * no active selection, will compare current input value against available labels\r\n     */\r\n    confirmOnBlur: true,\r\n\r\n    /**\r\n     * @description Allow multiple items to be selected\r\n     */\r\n    multiple: false,\r\n    /**\r\n     * @description @todo Adjust input width to match its value.\r\n     * Experimental, and a performance hit\r\n     */\r\n    autoGrow: false,\r\n    /**\r\n     * @description Maximum number of items that can be selected\r\n     */\r\n    maxItems: 9999,\r\n    /**\r\n     * @description If initialised element is an input, and in multiple mode,\r\n     * character that separates the selected values e.g. \"GLP,ZWE\"\r\n     */\r\n    multipleSeparator: ',',\r\n    /**\r\n     * @description If input is empty and in multiple mode,\r\n     * delete last selected item on backspace\r\n     */\r\n    deleteOnBackspace: false,\r\n\r\n    /**\r\n     * @description In async mode, parameter to use when adding the input value\r\n     * to the endpoint String. e.g. https://some-endpoint?q=norway&limit=9999\r\n     */\r\n    asyncQueryParam: 'q',\r\n    /**\r\n     * @description In async mode, parameter to use when adding results limit\r\n     * to the endpoint String. e.g. https://some-endpoint?q=norway&limit=9999\r\n     */\r\n    asyncMaxResultsParam: 'limit',\r\n\r\n    /**\r\n     * @description Placeholder text to show in generated input\r\n     */\r\n    placeholder: '',\r\n    /**\r\n     * @description Text to show (and announce to screen readers) if no results found.\r\n     * If empty, the list of options will remain hidden when there are no results\r\n     */\r\n    noResultsText: 'No results',\r\n    /**\r\n     * @description String to prepend to classes for BEM naming\r\n     * e.g. aria-autocomplete__input\r\n     */\r\n    cssNameSpace: 'aria-autocomplete',\r\n    /**\r\n     * @description Custom class name to add to the options list holder\r\n     */\r\n    listClassName: '',\r\n    /**\r\n     * @description Custom class name to add to the generated input\r\n     */\r\n    inputClassName: '',\r\n    /**\r\n     * @description Custom class name to add to the component wrapper\r\n     */\r\n    wrapperClassName: '',\r\n\r\n    /**\r\n     * @description In multiple mode, screen reader text used for element deletion.\r\n     * Prepended to option label in aria-label attribute e.g. 'delete Canada'\r\n     */\r\n    srDeleteText: 'delete',\r\n    /**\r\n     * @description Screen reader text announced after deletion.\r\n     * Apended to option label e.g. 'Canada deleted'\r\n     */\r\n    srDeletedText: 'deleted',\r\n    /**\r\n     * @description Value for aria-label attribute on the show all control\r\n     */\r\n    srShowAllText: 'Show all',\r\n    /**\r\n     * @description Screen reader text announced after confirming a selection.\r\n     * Appended to option label e.g. 'Canada selected'\r\n     */\r\n    srSelectedText: 'selected',\r\n    /**\r\n     * @description Screen reader explainer added to the list element\r\n     * via aria-label attribute\r\n     */\r\n    srListLabelText: 'Search suggestions',\r\n    /**\r\n     * @description Screen reader description announced when the input receives focus.\r\n     * Only announced when input is empty\r\n     */\r\n    srAssistiveText:\r\n        'When results are available use up and down arrows to review and ' +\r\n        'enter to select. Touch device users, explore by touch or with swipe gestures.',\r\n    /**\r\n     * @description Screen reader announcement after results are rendered\r\n     */\r\n    srResultsText: length =>\r\n        `${length} ${length === 1 ? 'result' : 'results'} available.`,\r\n\r\n    /**\r\n     * @description Callback before async call is made - receives the URL.\r\n     * Can be used to format the endpoint URL by returning a String\r\n     */\r\n    onAsyncPrep: undefined,\r\n    /**\r\n     * @description Callback after async call completes - receives the xhr object.\r\n     * Can be used to format the results by returning an Array\r\n     */\r\n    onAsyncSuccess: undefined,\r\n    /**\r\n     * @description Callback prior to rendering - receives the options that are going\r\n     * to render. Can be used to format the results by returning an Array\r\n     */\r\n    onResponse: undefined,\r\n    /**\r\n     * @description Callback before a search is performed - receives the input value.\r\n     * Can be used to alter the search value by returning a String\r\n     */\r\n    onSearch: undefined,\r\n    /**\r\n     * @description Callback after selection is made -\r\n     * receives an object with the option details\r\n     */\r\n    onConfirm: undefined,\r\n    /**\r\n     * @description Callback after an autocomplete selection is deleted.\r\n     * Fires in single-select mode when selection is deleted automatically.\r\n     * Fires in multi-select mode when selected is deleted by user action\r\n     */\r\n    onDelete: undefined,\r\n    /**\r\n     * @description Callback when main script processing and initial rendering has finished\r\n     */\r\n    onReady: undefined,\r\n    /**\r\n     * @description Callback when list area closes - receives the list holder element\r\n     */\r\n    onClose: undefined,\r\n    /**\r\n     * @description Callback when list area opens - receives the list holder element\r\n     */\r\n    onOpen: undefined\r\n};\r\n\r\n/**\r\n * @param {Element} element\r\n * @param {Object=} options\r\n */\r\nclass AriaAutocomplete {\r\n    constructor(element, options) {\r\n        // fail silently if no list provided\r\n        if (!element) {\r\n            return;\r\n        }\r\n\r\n        // if instance already exists on the list element, do not re-initialise\r\n        if (element.ariaAutocomplete) {\r\n            return element.ariaAutocomplete;\r\n        }\r\n\r\n        appIndex += 1;\r\n        // ids used for DOM queries and accessibility attributes e.g. aria-controls\r\n        this.ids = {};\r\n        this.ids.ELEMENT = element.id;\r\n        this.ids.PREFIX = `${element.id || ''}aria-autocomplete-${appIndex}`;\r\n        this.ids.LIST = `${this.ids.PREFIX}-list`;\r\n        this.ids.INPUT = `${this.ids.PREFIX}-input`;\r\n        this.ids.BUTTON = `${this.ids.PREFIX}-button`;\r\n        this.ids.OPTION = `${this.ids.PREFIX}-option`;\r\n        this.ids.WRAPPER = `${this.ids.PREFIX}-wrapper`;\r\n        this.ids.OPTION_SELECTED = `${this.ids.OPTION}-selected`;\r\n        this.ids.SR_ASSISTANCE = `${this.ids.PREFIX}-sr-assistance`;\r\n        this.ids.SR_ANNOUNCEMENTS = `${this.ids.PREFIX}-sr-announcements`;\r\n\r\n        // vars defined later - related explicitly to core initialising params\r\n        this.options;\r\n        this.element;\r\n        this.elementIsInput;\r\n        this.elementIsSelect;\r\n\r\n        // vars defined later - elements\r\n        this.list;\r\n        this.input;\r\n        this.wrapper;\r\n        this.showAll;\r\n        this.srAnnouncements;\r\n\r\n        // vars defined later - non elements\r\n        this.xhr;\r\n        this.term;\r\n        this.async;\r\n        this.source;\r\n        this.menuOpen;\r\n        this.multiple;\r\n        this.selected;\r\n        this.disabled;\r\n        this.filtering;\r\n        this.cssNameSpace;\r\n        this.forceShowAll;\r\n        this.filteredSource; // filtered source items to render\r\n        this.currentListHtml;\r\n        this.inputPollingValue;\r\n        this.currentSelectedIndex; // for storing index of currently focused option\r\n\r\n        // document click\r\n        this.documentClick;\r\n        this.documentClickBound;\r\n\r\n        // timers\r\n        this.filterTimer;\r\n        this.pollingTimer;\r\n        this.announcementTimer;\r\n        this.componentBlurTimer;\r\n        this.elementChangeEventTimer;\r\n\r\n        this.init(element, options);\r\n    }\r\n\r\n    /**\r\n     * trigger callbacks included in component options\r\n     * @param {String} name\r\n     * @param {Array=} args\r\n     * @param {Any=} args\r\n     */\r\n    triggerOptionCallback(name, args, context) {\r\n        context = typeof context === 'undefined' ? this.api : context;\r\n        if (typeof this.options[name] === 'function') {\r\n            return this.options[name].apply(context, args);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description show element with CSS only - if none provided, set list state to visible\r\n     * @param {Element=} element\r\n     */\r\n    show(element) {\r\n        if (typeof element !== 'undefined') {\r\n            let toRemove = `${this.cssNameSpace}--hide hide hidden`;\r\n            removeClass(element, toRemove);\r\n            return element.removeAttribute('hidden');\r\n        }\r\n\r\n        this.input.setAttribute('aria-expanded', 'true');\r\n        if (this.showAll) {\r\n            let expanded = (!!this.forceShowAll).toString();\r\n            this.showAll.setAttribute('aria-expanded', expanded);\r\n        }\r\n        if (!this.menuOpen) {\r\n            this.show(this.list);\r\n            this.menuOpen = true;\r\n            this.triggerOptionCallback('onOpen', [this.list]);\r\n            if (!this.documentClickBound) {\r\n                this.documentClickBound = true;\r\n                document.addEventListener('click', this.documentClick);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @description hide element with CSS only - if none provided, set list state to hidden\r\n     * @param {Element=} element\r\n     */\r\n    hide(element) {\r\n        if (typeof element !== 'undefined') {\r\n            addClass(element, `${this.cssNameSpace}--hide hide hidden`);\r\n            return element.setAttribute('hidden', 'hidden');\r\n        }\r\n\r\n        this.currentSelectedIndex = -1;\r\n        this.input.setAttribute('aria-expanded', 'false');\r\n        if (this.showAll) {\r\n            this.showAll.setAttribute('aria-expanded', 'false');\r\n        }\r\n        if (this.menuOpen) {\r\n            this.hide(this.list);\r\n            this.menuOpen = false;\r\n            this.triggerOptionCallback('onClose', [this.list]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description enable autocomplete (e.g. when under maxItems selected)\r\n     */\r\n    enable() {\r\n        if (this.disabled) {\r\n            this.disabled = false;\r\n            this.input.disabled = false;\r\n            let n = this.cssNameSpace;\r\n            removeClass(this.input, `${n}__input--disabled disabled`);\r\n            removeClass(this.wrapper, `${n}__wrapper--disabled disabled`);\r\n            if (this.showAll) {\r\n                this.showAll.setAttribute('tabindex', '0');\r\n                removeClass(this.showAll, `${n}__show-all--disabled disabled`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description disable autocomplete (e.g. when maxItems selected)\r\n     */\r\n    disable() {\r\n        if (!this.disabled) {\r\n            this.disabled = true;\r\n            this.input.disabled = true;\r\n            let n = this.cssNameSpace;\r\n            addClass(this.input, `${n}__input--disabled disabled`);\r\n            addClass(this.wrapper, `${n}__wrapper--disabled disabled`);\r\n            if (this.showAll) {\r\n                this.showAll.setAttribute('tabindex', '-1');\r\n                addClass(this.showAll, `${n}__show-all--disabled disabled`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description check if current input value is contained in a selection of options\r\n     * @param {String} query - string to use - checks input value otherwise\r\n     * @param {Array} options - array of objects with value and label properties\r\n     * @param {String=} prop - prop to check against in options array - defaults to 'label'\r\n     * @returns {Number} index of array entry that matches, or -1 if none found\r\n     */\r\n    isQueryContainedIn(query, options, prop) {\r\n        query = trimString(query || this.input.value).toLowerCase();\r\n        if (query) {\r\n            prop = prop || 'label';\r\n            for (let i = 0, l = options.length; i < l; i += 1) {\r\n                if (trimString(options[i][prop]).toLowerCase() === query) {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * @description make a screen reader announcement\r\n     * @param {String} text\r\n     * @param {Number=} delay\r\n     */\r\n    announce(text, delay) {\r\n        if (!text || !this.srAnnouncements) {\r\n            return;\r\n        }\r\n        // in immediate case, do not user timer\r\n        if (delay === 0) {\r\n            return (this.srAnnouncements.textContent = text);\r\n        }\r\n        delay = typeof delay === 'number' ? delay : 400;\r\n        if (this.announcementTimer) {\r\n            clearTimeout(this.announcementTimer);\r\n        }\r\n        this.announcementTimer = setTimeout(() => {\r\n            this.srAnnouncements.textContent = text;\r\n        }, delay);\r\n    }\r\n\r\n    /**\r\n     * @description check if element is a selected element in the DOM\r\n     * @param {Element} element\r\n     * @returns {Boolean}\r\n     */\r\n    isSelectedElem(element) {\r\n        return (\r\n            this.multiple &&\r\n            element.ariaAutocompleteSelectedOption &&\r\n            hasClass(element, `${this.cssNameSpace}__selected`)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @description get DOM elements for selected items\r\n     * @returns {Element[]}\r\n     */\r\n    getSelectedElems() {\r\n        let n = this.wrapper.childNodes;\r\n        let a = [];\r\n        for (let i = 0, l = n.length; i < l; i += 1) {\r\n            if (this.isSelectedElem(n[i])) {\r\n                a.push(n[i]);\r\n            }\r\n        }\r\n        return a;\r\n    }\r\n\r\n    /**\r\n     * @description remove object from selected\r\n     * @param {Object} entry\r\n     */\r\n    removeEntryFromSelected(entry) {\r\n        let index = this.selected.indexOf(entry);\r\n        if (index === -1) {\r\n            // value check, in case explicit object reference did not work\r\n            for (let i = 0, l = this.selected.length; i < l; i += 1) {\r\n                if (this.selected[i].value === entry.value) {\r\n                    index = i;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // set element state, dispatch change event, set selected array,\r\n        // trigger callback, build selected, and do screen reader announcement\r\n        if (index > -1 && this.selected[index]) {\r\n            let option = mergeObjects(this.selected[index]);\r\n            let label = option.label;\r\n            setElementState(this.selected.element, false, this);\r\n            this.selected.splice(index, 1);\r\n            this.triggerOptionCallback('onDelete', [option]);\r\n            this.buildMultiSelected();\r\n            this.announce(`${label} ${this.options.srDeletedText}`, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description re-build the html showing the selected items\r\n     * @todo: test performance in old IE - lots of loops here!\r\n     */\r\n    buildMultiSelected() {\r\n        // only do anything in multiple mode\r\n        if (!this.multiple) {\r\n            return;\r\n        }\r\n\r\n        // no elements, and none selected, do nothing\r\n        let currentSelectedElems = this.getSelectedElems();\r\n        if (!this.selected.length && !currentSelectedElems.length) {\r\n            return;\r\n        }\r\n\r\n        // cycle through existing elements, and remove any not in the selected array\r\n        let current = [];\r\n        let i = currentSelectedElems.length;\r\n        while (i--) {\r\n            let option = currentSelectedElems[i].ariaAutocompleteSelectedOption;\r\n            let l = this.selected.length;\r\n            let isInSelected = false;\r\n            while (l--) {\r\n                let selected = this.selected[l];\r\n                if (selected === option || selected.value === option.value) {\r\n                    isInSelected = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (isInSelected) {\r\n                current.push(currentSelectedElems[i]);\r\n            } else {\r\n                this.wrapper.removeChild(currentSelectedElems[i]);\r\n            }\r\n        }\r\n\r\n        // cycle through selected array, and add elements for any not represented by one\r\n        let deleteText = this.options.srDeleteText;\r\n        let fragment = document.createDocumentFragment();\r\n        let selectedClass = `${this.cssNameSpace}__selected`;\r\n        for (let i = 0, l = this.selected.length; i < l; i += 1) {\r\n            let selected = this.selected[i];\r\n            let l = current.length;\r\n            let isInDom = false;\r\n            while (l--) {\r\n                let option = current[l].ariaAutocompleteSelectedOption;\r\n                if (option === selected || option.value === selected.value) {\r\n                    isInDom = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!isInDom) {\r\n                let label = selected.label;\r\n                let span = htmlToElement(\r\n                    `<span role=\"button\" class=\"${selectedClass}\" ` +\r\n                        `tabindex=\"0\" aria-label=\"${deleteText} ${label}\">` +\r\n                        `${label}</span>`\r\n                );\r\n                span.ariaAutocompleteSelectedOption = selected;\r\n                fragment.appendChild(span);\r\n            }\r\n        }\r\n        if (fragment.childNodes && fragment.childNodes.length) {\r\n            this.wrapper.insertBefore(fragment, this.list);\r\n        }\r\n\r\n        // set ids on elements\r\n        let ids = [];\r\n        current = this.getSelectedElems();\r\n        for (let i = 0, l = current.length; i < l; i += 1) {\r\n            let id = `${this.ids.OPTION_SELECTED}-${i}`;\r\n            current[i].setAttribute('id', id);\r\n            ids.push(id);\r\n        }\r\n        ids.push(this.ids.LIST);\r\n\r\n        // set input aria-owns\r\n        this.input.setAttribute('aria-owns', ids.join(' '));\r\n\r\n        // in autogrow mode, hide the placeholder if there are selected items\r\n        if (this.autoGrow && this.options.placeholder) {\r\n            let toSet = this.selected.length ? '' : this.options.placeholder;\r\n            this.input.setAttribute('placeholder', toSet);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description set the aria-describedby attribute on the input\r\n     */\r\n    setInputDescription() {\r\n        let exists = this.input.getAttribute('aria-describedby');\r\n        let current = trimString(exists || '');\r\n        let describedBy = current.replace(this.ids.SR_ASSISTANCE, '');\r\n\r\n        if (this.input.value.length === 0) {\r\n            describedBy = describedBy + ' ' + this.ids.SR_ASSISTANCE;\r\n        }\r\n\r\n        // set or remove attribute, but only if necessary\r\n        if ((describedBy = trimString(describedBy))) {\r\n            if (describedBy !== current) {\r\n                this.input.setAttribute('aria-describedby', describedBy);\r\n            }\r\n        } else if (exists) {\r\n            this.input.removeAttribute('aria-describedby');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description reset classes and aria-selected attribute for all visible filtered options\r\n     */\r\n    resetOptionAttributes() {\r\n        let cssName = this.cssNameSpace;\r\n        let nodes = this.list.childNodes;\r\n        let l = nodes.length;\r\n\r\n        while (l--) {\r\n            removeClass(nodes[l], `${cssName}__option--focused focused focus`);\r\n            nodes[l].setAttribute('aria-selected', 'false');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description move focus to correct option, or to input (on up and down arrows)\r\n     * @param {Event} event\r\n     * @param {Number} index\r\n     */\r\n    setOptionFocus(event, index) {\r\n        // set aria-selected to false and remove focused class\r\n        this.resetOptionAttributes();\r\n\r\n        // if negative index, or no options available, focus on input\r\n        let options = this.list.childNodes;\r\n        if (index < 0 || !options || !options.length) {\r\n            this.currentSelectedIndex = -1;\r\n            // focus on input, only if event was from another element\r\n            if (event && event.target !== this.input) {\r\n                this.input.focus();\r\n            }\r\n            return;\r\n        }\r\n\r\n        // down arrow on/past last option, focus on last item\r\n        if (index >= options.length) {\r\n            this.currentSelectedIndex = options.length - 1;\r\n            this.setOptionFocus(event, this.currentSelectedIndex);\r\n            return;\r\n        }\r\n\r\n        // if option found, focus...\r\n        let toFocus = options[index];\r\n        if (toFocus && typeof toFocus.getAttribute('tabindex') === 'string') {\r\n            this.currentSelectedIndex = index;\r\n            let toAdd = `${this.cssNameSpace}__option--focused focused focus`;\r\n            addClass(toFocus, toAdd);\r\n            toFocus.setAttribute('aria-selected', 'true');\r\n            toFocus.focus();\r\n            return;\r\n        }\r\n\r\n        // reset index just in case\r\n        this.currentSelectedIndex = -1;\r\n    }\r\n\r\n    /**\r\n     * @description set values and dispatch events based on any DOM elements in the selected array\r\n     */\r\n    setSourceElementValues() {\r\n        let valToSet = [];\r\n        for (let i = 0, l = this.selected.length; i < l; i += 1) {\r\n            let entry = this.selected[i];\r\n            valToSet.push(entry.value);\r\n            setElementState(entry.element, true, this); // element processing\r\n        }\r\n\r\n        // set original input value\r\n        if (this.elementIsInput) {\r\n            let valToSetString = valToSet.join(this.options.multipleSeparator);\r\n            if (valToSetString !== this.element.value) {\r\n                this.element.value = valToSetString;\r\n                dispatchEvent(this.element, 'change');\r\n            }\r\n        }\r\n\r\n        // included in case of multi-select mode used with a <select> element as the source\r\n        if (!this.selected.length && this.elementIsSelect) {\r\n            this.element.value = '';\r\n        }\r\n\r\n        // set disabled state as needed\r\n        if (this.multiple && this.selected.length >= this.options.maxItems) {\r\n            return this.disable();\r\n        }\r\n        this.enable();\r\n    }\r\n\r\n    /**\r\n     * @description select option from the list by index\r\n     * @param {Event} event\r\n     * @param {Number} index\r\n     * @param {Boolean=} focusAfterSelection\r\n     */\r\n    handleOptionSelect(event, index, focusAfterSelection = true) {\r\n        // defensive check for proper index, that the filteredSource exists, and not exceed max items option\r\n        if (\r\n            typeof index !== 'number' ||\r\n            index < 0 ||\r\n            (this.multiple && this.selected.length >= this.options.maxItems) ||\r\n            !this.filteredSource.length ||\r\n            !this.filteredSource[index]\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        // generate new object from the selected item in case the original source gets altered\r\n        let option = mergeObjects(this.filteredSource[index]);\r\n\r\n        // detect if selected option is already in selected array\r\n        let l = this.selected.length;\r\n        let alreadySelected = false;\r\n        while (l--) {\r\n            if (this.selected[l].value === option.value) {\r\n                alreadySelected = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        let valToSet = this.multiple ? '' : option.label;\r\n        this.input.value = this.term = this.inputPollingValue = valToSet;\r\n\r\n        // reset selected array in single select mode\r\n        if (!alreadySelected && !this.multiple) {\r\n            this.selected = [];\r\n        }\r\n\r\n        // (re)set values of any DOM elements based on selected array\r\n        if (!alreadySelected) {\r\n            this.selected.push(option);\r\n            this.setSourceElementValues();\r\n            this.buildMultiSelected(); // rebuild multi-selected if needed\r\n        }\r\n\r\n        this.triggerOptionCallback('onConfirm', [option]);\r\n        this.announce(`${option.label} ${this.options.srSelectedText}`, 0);\r\n\r\n        // return focus to input\r\n        if (!this.disabled && focusAfterSelection !== false) {\r\n            this.input.focus();\r\n        }\r\n\r\n        // close menu after option selection, and after returning focus to input\r\n        this.hide();\r\n    }\r\n\r\n    /**\r\n     * @description remove selected entries from results if in multiple mode\r\n     * @param {Array} results\r\n     * @returns {Array}\r\n     */\r\n    removeSelectedFromResults(results) {\r\n        if (!this.multiple || !this.selected.length) {\r\n            return results;\r\n        }\r\n        let toReturn = [];\r\n        resultsLoop: for (let i = 0, l = results.length; i < l; i += 1) {\r\n            let selected = this.selected;\r\n            let result = results[i];\r\n            for (let j = 0, k = selected.length; j < k; j += 1) {\r\n                let labelMatch = result.label === selected[j].label;\r\n                if (labelMatch && result.value === selected[j].value) {\r\n                    continue resultsLoop;\r\n                }\r\n            }\r\n            toReturn.push(result);\r\n        }\r\n        return toReturn;\r\n    }\r\n\r\n    /**\r\n     * @description final filtering and render for list options, and render\r\n     * @param {Array} results\r\n     */\r\n    setListOptions(results) {\r\n        let toShow = [];\r\n        let optionId = this.ids.OPTION;\r\n        let cssName = this.cssNameSpace;\r\n        let mapping = this.options.sourceMapping;\r\n        // if in multiple mode, exclude items already in the selected array\r\n        let updated = this.removeSelectedFromResults(results);\r\n        // allow callback to alter the response before rendering\r\n        let callback = this.triggerOptionCallback('onResponse', updated);\r\n\r\n        // now commit to setting the filtered source\r\n        this.filteredSource = callback\r\n            ? processSourceArray(callback, mapping)\r\n            : updated;\r\n        let length = this.filteredSource.length;\r\n\r\n        // build up the list html\r\n        let maxResults = this.forceShowAll ? 9999 : this.options.maxResults;\r\n        for (let i = 0; i < length && i < maxResults; i += 1) {\r\n            toShow.push(\r\n                `<li tabindex=\"-1\" aria-selected=\"false\" role=\"option\" class=\"${cssName}__option\" ` +\r\n                    `id=\"${optionId}--${i}\" aria-posinset=\"${i + 1}\" ` +\r\n                    `aria-setsize=\"${length}\">${this.filteredSource[i].label}</li>`\r\n            );\r\n        }\r\n\r\n        // set has-results or no-results class on the list element\r\n        if (toShow.length) {\r\n            addClass(this.list, `${cssName}__list--has-results`);\r\n            removeClass(this.list, `${cssName}__list--no-results`);\r\n        } else {\r\n            removeClass(this.list, `${cssName}__list--has-results`);\r\n            addClass(this.list, `${cssName}__list--no-results`);\r\n        }\r\n\r\n        // no results text handling\r\n        let announce;\r\n        let noText = this.options.noResultsText;\r\n        if (!toShow.length && typeof noText === 'string' && noText.length) {\r\n            announce = noText;\r\n            let optionClass = `${cssName}__option`;\r\n            toShow.push(\r\n                `<li class=\"${optionClass} ${optionClass}--no-results\">${noText}</li>`\r\n            );\r\n        }\r\n\r\n        // remove loading class(es) and reset variables\r\n        this.cancelFilterPrep();\r\n\r\n        // announce to screen reader\r\n        if (!announce) {\r\n            announce = this.triggerOptionCallback('srResultsText', [length]);\r\n        }\r\n        this.announce(announce);\r\n\r\n        // render the list, only if we have to\r\n        // time taken for string comparison is worth it to not have to re-parse and re-render the list\r\n        let newListHtml = toShow.join('');\r\n        if (this.currentListHtml !== newListHtml) {\r\n            this.currentListHtml = newListHtml;\r\n            /** @todo: test innerHTML vs insertAdjacentHtml performance in old IE */\r\n            this.list.innerHTML = newListHtml;\r\n        } else {\r\n            // if list html matches, and not re-rendered, clear aria-selected and focus classes\r\n            this.resetOptionAttributes();\r\n        }\r\n\r\n        // if toShow array is empty, make sure not to render the menu\r\n        if (!toShow.length) {\r\n            this.hide();\r\n            this.forceShowAll = false;\r\n            return;\r\n        }\r\n\r\n        this.show();\r\n        // reset forceShowAll must be after .show()\r\n        // aria-expanded attribute on showAllControl is controlled in .show() method\r\n        this.forceShowAll = false;\r\n    }\r\n\r\n    /**\r\n     * @description trigger async call for options to render\r\n     * @param {String} value\r\n     * @param {Boolean=} isFirstCall\r\n     */\r\n    handleAsync(value, isFirstCall = false) {\r\n        let xhr = new XMLHttpRequest();\r\n        let encode = encodeURIComponent;\r\n        let isShowAll = this.forceShowAll;\r\n        let unlimited = isShowAll || isFirstCall;\r\n        let baseAmount = this.multiple ? this.selected.length : 0;\r\n        let ampersandOrQuestionMark = /\\?/.test(this.source) ? '&' : '?';\r\n        let url =\r\n            this.source +\r\n            ampersandOrQuestionMark +\r\n            `${encode(this.options.asyncQueryParam)}=${encode(value)}&` +\r\n            `${encode(this.options.asyncMaxResultsParam)}=` +\r\n            `${unlimited ? 9999 : baseAmount + this.options.maxResults}`;\r\n\r\n        // abort any current call first\r\n        if (this.xhr) {\r\n            this.xhr.abort();\r\n        }\r\n\r\n        let context = isFirstCall ? null : this.api;\r\n        url = this.triggerOptionCallback('onAsyncPrep', [url], context) || url;\r\n\r\n        xhr.open('GET', url);\r\n        xhr.onload = () => {\r\n            if (xhr.readyState === xhr.DONE) {\r\n                if (xhr.status === 200) {\r\n                    this.forceShowAll = isShowAll; // return forceShowAll to previous state before the options render\r\n                    let context = isFirstCall ? null : this.api;\r\n                    let callbackResponse = this.triggerOptionCallback(\r\n                        'onAsyncSuccess',\r\n                        [value, xhr],\r\n                        context\r\n                    );\r\n                    let mapping = this.options.sourceMapping;\r\n                    let source = callbackResponse || xhr.responseText;\r\n                    let items = processSourceArray(source, mapping, false);\r\n\r\n                    if (isFirstCall) {\r\n                        this.prepSelectedFromArray(items);\r\n                    } else {\r\n                        this.setListOptions(items);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        // allow the creation of an uncancellable call to use on first load\r\n        if (!isFirstCall) {\r\n            this.xhr = xhr;\r\n        }\r\n\r\n        xhr.send();\r\n    }\r\n\r\n    /**\r\n     * @description trigger filtering using a value\r\n     * @param {String} value\r\n     */\r\n    filter(value) {\r\n        // fail silently if no value is provided\r\n        if (typeof value !== 'string') {\r\n            this.cancelFilterPrep();\r\n            return;\r\n        }\r\n\r\n        let forceShowAll = this.forceShowAll;\r\n        let callbackResponse = this.triggerOptionCallback('onSearch', [value]);\r\n        let toReturn = [];\r\n\r\n        // allow onSearch callback to affect the searched value\r\n        // only permitted when not a forceShowAll case\r\n        if (!forceShowAll && typeof callbackResponse === 'string') {\r\n            value = callbackResponse;\r\n        }\r\n\r\n        // store search term - used for comparison in filterPrep\r\n        this.term = this.inputPollingValue = value;\r\n\r\n        // async handling\r\n        if (this.async) {\r\n            this.handleAsync(value);\r\n            // set show all to false immediately as may be used in other places\r\n            this.forceShowAll = false;\r\n            return;\r\n        }\r\n\r\n        // handle the source as a function\r\n        if (typeof this.source === 'function') {\r\n            this.source.call(this.api, this.term, response => {\r\n                let mapping = this.options.mapping;\r\n                let result = processSourceArray(response, mapping);\r\n                this.setListOptions(result);\r\n            });\r\n            return;\r\n        }\r\n\r\n        // if empty string, show all\r\n        if (!value) {\r\n            forceShowAll = true;\r\n        }\r\n\r\n        // existing list handling\r\n        if (this.source && this.source.length) {\r\n            if (!forceShowAll) {\r\n                value = cleanString(value);\r\n            }\r\n            for (let i = 0, l = this.source.length; i < l; i += 1) {\r\n                let entry = this.source[i];\r\n                if (forceShowAll || entry.cleanedLabel.search(value) !== -1) {\r\n                    toReturn.push({\r\n                        element: entry.element,\r\n                        staticSourceIndex: i,\r\n                        label: entry.label,\r\n                        value: entry.value\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setListOptions(toReturn);\r\n    }\r\n\r\n    /**\r\n     * @description cancel filter timer and remove loading classes\r\n     */\r\n    cancelFilterPrep() {\r\n        if (this.filterTimer) {\r\n            clearTimeout(this.filterTimer);\r\n        }\r\n        let nameSpace = this.cssNameSpace;\r\n        removeClass(this.wrapper, `${nameSpace}__wrapper--loading loading`);\r\n        removeClass(this.input, `${nameSpace}__input--loading loading`);\r\n        this.filtering = false;\r\n    }\r\n\r\n    /**\r\n     * @description checks before filtering, and set filter timer\r\n     * @param {Event} e\r\n     * @param {Boolean=} doValueOverrideCheck - whether to check input value against selected item(s)\r\n     * @param {Boolean=} runNow\r\n     */\r\n    filterPrep(e, doValueOverrideCheck = false, runNow = false) {\r\n        let forceShowAll = this.forceShowAll;\r\n        let delay = forceShowAll || runNow ? 0 : this.options.delay;\r\n\r\n        // clear timers\r\n        this.cancelFilterPrep();\r\n        this.filtering = true;\r\n        this.filterTimer = setTimeout(() => {\r\n            let value = this.input.value;\r\n            // treat as empty search if...\r\n            // forceShowAll, or in single mode and selected item label matches current value\r\n            if (\r\n                forceShowAll ||\r\n                value === '' ||\r\n                (doValueOverrideCheck &&\r\n                    !this.multiple &&\r\n                    this.selected.length &&\r\n                    trimString(this.selected[0].label) === trimString(value))\r\n            ) {\r\n                value = '';\r\n            }\r\n\r\n            // handle aria-describedby\r\n            this.setInputDescription();\r\n            this.inputPollingValue = value;\r\n\r\n            if (!forceShowAll && value.length < this.options.minLength) {\r\n                this.hide();\r\n                return;\r\n            }\r\n\r\n            // try catch used due to permissions issues in some cases\r\n            let modifier;\r\n            try {\r\n                let keydown = e && e.type === 'keydown';\r\n                modifier = keydown && (e.altKey || e.ctrlKey || e.metaKey); // allow shift key, just in case...\r\n            } catch (e) {}\r\n\r\n            // if value to use matches last used search term, do nothing\r\n            let equalVals = value === '' ? false : value === this.term;\r\n\r\n            // prevent search being run again with the same value\r\n            if (!equalVals || (equalVals && !this.menuOpen && !modifier)) {\r\n                let n = this.cssNameSpace;\r\n                addClass(this.wrapper, `${n}__wrapper--loading loading`);\r\n                addClass(this.input, `${n}__input--loading loading`);\r\n                this.currentSelectedIndex = -1;\r\n                this.filter(value);\r\n            }\r\n        }, delay);\r\n    }\r\n\r\n    /**\r\n     * @description trigger filter prep in showAll mode\r\n     * @param {Event} event\r\n     */\r\n    filterPrepShowAll(event) {\r\n        if (this.componentBlurTimer) {\r\n            clearTimeout(this.componentBlurTimer);\r\n        }\r\n        event.preventDefault();\r\n        this.forceShowAll = true;\r\n        this.filterPrep(event, false, true);\r\n    }\r\n\r\n    /**\r\n     * @description blur behaviour for hiding list and removing focus class(es)\r\n     * @param {Event} event\r\n     * @param {Boolean=} force - fire instantly and force blurring out of the component\r\n     */\r\n    handleComponentBlur(event, force = false) {\r\n        let delay = force ? 0 : 100;\r\n        if (this.componentBlurTimer) {\r\n            clearTimeout(this.componentBlurTimer);\r\n        }\r\n        // use a timeout to ensure this blur fires after other focus events\r\n        // and in case the user focuses back in immediately\r\n        this.componentBlurTimer = setTimeout(() => {\r\n            // do nothing if blurring to an element within the list\r\n            let activeElem = document.activeElement;\r\n            if (\r\n                !force &&\r\n                !(this.showAll && this.showAll === activeElem) && // exception for show all button\r\n                !activeElem.ariaAutocompleteSelectedOption // exception for selected items\r\n            ) {\r\n                // must base this on the wrapper to allow scrolling the list in IE\r\n                if (this.wrapper.contains(activeElem)) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            // cancel any running async call\r\n            if (this.xhr) {\r\n                this.xhr.abort();\r\n            }\r\n\r\n            // confirmOnBlur behaviour\r\n            let isQueryIn = this.isQueryContainedIn.bind(this);\r\n            if (!force && this.options.confirmOnBlur && this.menuOpen) {\r\n                // if blurring from an option (currentSelectedIndex > -1), select it\r\n                let toUse = this.currentSelectedIndex;\r\n                if (typeof toUse !== 'number' || toUse === -1) {\r\n                    // otherwise check for exact match between current input value and available items\r\n                    toUse = isQueryIn('', this.filteredSource);\r\n                }\r\n                this.handleOptionSelect({}, toUse, false);\r\n            }\r\n\r\n            let n = this.cssNameSpace;\r\n            removeClass(this.wrapper, `${n}__wrapper--focused focused focus`);\r\n            removeClass(this.input, `${n}__input--focused focused focus`);\r\n            this.cancelFilterPrep();\r\n            this.hide();\r\n\r\n            // in single select case, if current value and chosen value differ, clear selected and input value\r\n            if (!this.multiple && isQueryIn('', this.selected) === -1) {\r\n                let isInputOrDdl = this.elementIsInput || this.elementIsSelect;\r\n                if (isInputOrDdl && this.element.value !== '') {\r\n                    this.element.value = '';\r\n                    dispatchEvent(this.element, 'change');\r\n                }\r\n                if (this.selected.length) {\r\n                    this.removeEntryFromSelected(this.selected[0]);\r\n                }\r\n                this.input.value = '';\r\n            }\r\n\r\n            // unbind document click\r\n            if (this.documentClickBound) {\r\n                this.documentClickBound = false;\r\n                document.removeEventListener('click', this.documentClick);\r\n            }\r\n        }, delay);\r\n    }\r\n\r\n    /**\r\n     * @description enter keydown for selections\r\n     * @param {Event} event\r\n     */\r\n    handleEnterKey(event) {\r\n        // if in multiple mode, and event target was a selected item, remove it\r\n        if (this.isSelectedElem(event.target)) {\r\n            let option = event.target.ariaAutocompleteSelectedOption;\r\n            return this.removeEntryFromSelected(option);\r\n        }\r\n\r\n        if (this.disabled) {\r\n            return;\r\n        }\r\n\r\n        if (this.showAll && event.target === this.showAll) {\r\n            this.filterPrepShowAll(event);\r\n            return;\r\n        }\r\n\r\n        if (this.menuOpen) {\r\n            event.preventDefault();\r\n            if (this.currentSelectedIndex > -1) {\r\n                this.handleOptionSelect(event, this.currentSelectedIndex);\r\n            }\r\n        }\r\n\r\n        // if enter keypress was from the filter input, trigger search immediately\r\n        if (event.target === this.input) {\r\n            this.filterPrep(event, false, true);\r\n        }\r\n    }\r\n    /**\r\n     * @description down arrow usage - option focus, or search all\r\n     * @param {Event} event\r\n     */\r\n    handleDownArrowKey(event) {\r\n        event.preventDefault();\r\n        // if closed, and text is long enough, run search\r\n        if (!this.menuOpen) {\r\n            this.forceShowAll = this.options.minLength < 1;\r\n            if (\r\n                this.forceShowAll ||\r\n                this.input.value.length >= this.options.minLength\r\n            ) {\r\n                this.filterPrep(event);\r\n            }\r\n        }\r\n        // move focus to downward option\r\n        if (this.menuOpen && !this.filtering) {\r\n            let current = this.currentSelectedIndex;\r\n            if (typeof current !== 'number' || current < 0) {\r\n                this.setOptionFocus(event, 0);\r\n            } else {\r\n                this.setOptionFocus(event, current + 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description up arrow usage - option focus, or return focus to input\r\n     * @param {Event} event\r\n     */\r\n    handleUpArrowKey(event) {\r\n        event.preventDefault();\r\n        let usable = !this.disabled && this.menuOpen;\r\n        if (usable && typeof this.currentSelectedIndex === 'number') {\r\n            this.setOptionFocus(event, this.currentSelectedIndex - 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description standard keydown handling (excluding enter, up, down, escape)\r\n     * @param {Event} event\r\n     */\r\n    handleKeyDownDefault(event) {\r\n        const targetIsInput = event.target === this.input;\r\n        // on space, if focus state is on any other item, treat as enter\r\n        if (event.keyCode === 32 && !targetIsInput) {\r\n            return this.handleEnterKey(event);\r\n        }\r\n\r\n        if (this.disabled) {\r\n            return;\r\n        }\r\n\r\n        // on backspace, if using empty input in multiple mode, delete last selected entry\r\n        let selectedLength = this.selected && this.selected.length;\r\n        if (\r\n            this.options.deleteOnBackspace &&\r\n            this.input.value === '' &&\r\n            event.keyCode === 8 &&\r\n            selectedLength &&\r\n            targetIsInput &&\r\n            this.multiple\r\n        ) {\r\n            return this.removeEntryFromSelected(this.selected.length - 1);\r\n        }\r\n\r\n        // any printable character not on input, return focus to input\r\n        let focusInput = !targetIsInput && isPrintableKey(event.keyCode);\r\n        if (focusInput) {\r\n            this.input.focus();\r\n        }\r\n\r\n        // trigger filtering - done here, instead of using input event, due to IE9 issues\r\n        if (focusInput || targetIsInput) {\r\n            this.filterPrep(event);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description component keydown handling\r\n     * @param {Event} event\r\n     */\r\n    prepKeyDown(event) {\r\n        switch (event.keyCode) {\r\n            case 13: // on enter\r\n                this.handleEnterKey(event);\r\n                break;\r\n            case 27: // on escape\r\n                this.handleComponentBlur(event, true);\r\n                break;\r\n            case 38: // on up\r\n                this.handleUpArrowKey(event);\r\n                break;\r\n            case 40: // on down\r\n                this.handleDownArrowKey(event);\r\n                break;\r\n            default:\r\n                this.handleKeyDownDefault(event);\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description cancel checking for input value changes from external causes\r\n     */\r\n    cancelPolling() {\r\n        if (this.pollingTimer) {\r\n            clearTimeout(this.pollingTimer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description start checking for input value changes from causes that bypass event detection\r\n     */\r\n    startPolling() {\r\n        // check if input value does not equal last searched term\r\n        if (!this.filtering && this.input.value !== this.inputPollingValue) {\r\n            this.filterPrep({});\r\n        }\r\n        this.pollingTimer = setTimeout(() => {\r\n            this.startPolling();\r\n        }, 200);\r\n    }\r\n\r\n    /**\r\n     * @description bind component events to generated elements\r\n     */\r\n    bindEvents() {\r\n        // when focus is moved outside of the component, close everything\r\n        this.wrapper.addEventListener('focusout', event => {\r\n            this.handleComponentBlur(event, false);\r\n        });\r\n        // set wrapper focus state\r\n        this.wrapper.addEventListener('focusin', event => {\r\n            let toAdd = `${this.cssNameSpace}__wrapper--focused focused focus`;\r\n            addClass(this.wrapper, toAdd);\r\n            if (!this.list.contains(event.target)) {\r\n                this.currentSelectedIndex = -1;\r\n            }\r\n        });\r\n        // handle all keydown events inside the component\r\n        this.wrapper.addEventListener('keydown', event => {\r\n            this.prepKeyDown(event);\r\n        });\r\n        // if clicking directly on the wrapper, move focus to the input\r\n        this.wrapper.addEventListener('click', event => {\r\n            if (event.target === this.wrapper) {\r\n                this.input.focus();\r\n                return;\r\n            }\r\n            if (this.isSelectedElem(event.target)) {\r\n                let option = event.target.ariaAutocompleteSelectedOption;\r\n                this.removeEntryFromSelected(option);\r\n            }\r\n        });\r\n\r\n        // when blurring out of input, check current value against selected one and clear if needed\r\n        this.input.addEventListener('blur', () => {\r\n            let toRemove = `${this.cssNameSpace}__input--focused focused focus`;\r\n            removeClass(this.input, toRemove);\r\n            this.cancelPolling();\r\n        });\r\n        // trigger filter on input event as well as keydown (covering bases)\r\n        this.input.addEventListener('input', event => {\r\n            this.filterPrep(event);\r\n        });\r\n        // when specifically clicking on input, if menu is closed, and value is long enough, search\r\n        this.input.addEventListener('click', event => {\r\n            let open = this.menuOpen;\r\n            if (!open && this.input.value.length >= this.options.minLength) {\r\n                this.filterPrep(event, true);\r\n            }\r\n        });\r\n        // when focusing on input, reset selected index and trigger search handling\r\n        this.input.addEventListener('focusin', () => {\r\n            let toAdd = `${this.cssNameSpace}__input--focused focused focus`;\r\n            addClass(this.input, toAdd);\r\n            this.startPolling();\r\n            if (!this.disabled && !this.menuOpen) {\r\n                this.filterPrep(event, true);\r\n            }\r\n        });\r\n\r\n        // show all button click\r\n        if (this.showAll) {\r\n            this.showAll.addEventListener('click', event => {\r\n                this.filterPrepShowAll(event);\r\n            });\r\n        }\r\n\r\n        // clear any current focus position when hovering into the list\r\n        this.list.addEventListener('mouseenter', event => {\r\n            this.resetOptionAttributes();\r\n        });\r\n        // trigger options selection\r\n        this.list.addEventListener('click', event => {\r\n            if (event.target !== this.list) {\r\n                let childNodes = this.list.childNodes;\r\n                if (childNodes.length) {\r\n                    let nodeIndex = [].indexOf.call(childNodes, event.target);\r\n                    this.handleOptionSelect(event, nodeIndex);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @description set starting source array based on child checkboxes\r\n     */\r\n    prepListSourceCheckboxes() {\r\n        this.multiple = true; // force multiple in this case\r\n        // reset source and use checkboxes\r\n        this.source = [];\r\n        let elements = this.element.querySelectorAll('input[type=\"checkbox\"]');\r\n        for (let i = 0, l = elements.length; i < l; i += 1) {\r\n            let checkbox = elements[i];\r\n            // must have a value other than empty string\r\n            if (!checkbox.value) {\r\n                continue;\r\n            }\r\n            let toPush = { element: checkbox, value: checkbox.value };\r\n            // label searching\r\n            let label = checkbox.closest('label');\r\n            if (!label && checkbox.id) {\r\n                label = document.querySelector('[for=\"' + checkbox.id + '\"]');\r\n            }\r\n            if (label) {\r\n                toPush.label = label.textContent;\r\n            }\r\n            // if no label so far, re-use value\r\n            if (!toPush.label) {\r\n                toPush.label = toPush.value;\r\n            }\r\n            toPush.cleanedLabel = cleanString(toPush.label);\r\n            this.source.push(toPush);\r\n            // add to selected if applicable\r\n            if (checkbox.checked) {\r\n                this.selected.push(toPush);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description set starting source array based on <select> options\r\n     */\r\n    prepListSourceDdl() {\r\n        this.multiple = this.element.multiple; // force multiple to match select\r\n        // reset source and use options\r\n        this.source = [];\r\n        let options = this.element.querySelectorAll('option');\r\n        for (let i = 0, l = options.length; i < l; i += 1) {\r\n            let option = options[i];\r\n            // must have a value other than empty string\r\n            if (!option.value) {\r\n                continue;\r\n            }\r\n            let toPush = {\r\n                element: option,\r\n                value: option.value,\r\n                label: option.textContent\r\n            };\r\n            toPush.cleanedLabel = cleanString(toPush.label);\r\n            this.source.push(toPush);\r\n            // add to selected if applicable\r\n            if (option.selected) {\r\n                this.selected.push(toPush);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description build up selected array if starting element was an input, and had a value\r\n     * @param {Object[]} source\r\n     */\r\n    prepSelectedFromArray(source) {\r\n        let value = this.elementIsInput && this.element.value;\r\n        if (value && source && source.length) {\r\n            // account for multiple mode\r\n            let multiple = this.options.multiple;\r\n            let separator = this.options.multipleSeparator;\r\n            let valueArr = multiple ? value.split(separator) : [value];\r\n\r\n            for (let i = 0, l = valueArr.length; i < l; i += 1) {\r\n                let val = valueArr[i];\r\n                let isQueryIn = this.isQueryContainedIn;\r\n                // make sure it is not already in the selected array\r\n                let isInSelected = isQueryIn(val, this.selected, 'value') > -1;\r\n\r\n                // but is in the source array (check via 'value', not 'label')\r\n                if (!isInSelected) {\r\n                    let indexInSource = isQueryIn(val, source, 'value');\r\n                    if (indexInSource > -1) {\r\n                        this.selected.push(source[indexInSource]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description adjust starting source array to format needed, and set selected\r\n     */\r\n    prepListSourceArray() {\r\n        let mapping = this.options.sourceMapping;\r\n        this.source = processSourceArray(this.source, mapping);\r\n        this.prepSelectedFromArray(this.source);\r\n    }\r\n\r\n    /**\r\n     * @description trigger source string endpoint to generate selected array\r\n     */\r\n    prepListSourceAsync() {\r\n        this.async = true;\r\n        if (this.elementIsInput && this.element.value) {\r\n            this.handleAsync(this.element.value, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description process source function to generate selected array\r\n     */\r\n    prepListSourceFunction() {\r\n        if (this.elementIsInput && this.element.value) {\r\n            this.source.call(undefined, this.element.value, response => {\r\n                this.prepSelectedFromArray(processSourceArray(response));\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description adjust set sources to needed format\r\n     */\r\n    prepListSource() {\r\n        // allow complete control over the source handling via custom function\r\n        if (typeof this.source === 'function') {\r\n            return this.prepListSourceFunction();\r\n        }\r\n\r\n        // string source - treat as async endpoint\r\n        if (typeof this.source === 'string' && this.source.length) {\r\n            return this.prepListSourceAsync();\r\n        }\r\n\r\n        // array source - copy array\r\n        if (Array.isArray(this.source) && this.source.length) {\r\n            return this.prepListSourceArray();\r\n        }\r\n\r\n        // dropdown source\r\n        if (this.elementIsSelect) {\r\n            return this.prepListSourceDdl();\r\n        }\r\n\r\n        // checkboxlist source\r\n        if (this.element.querySelector('input[type=\"checkbox\"]')) {\r\n            this.prepListSourceCheckboxes();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description set input starting states - aria attributes, disabled state, starting value\r\n     */\r\n    setInputStartingStates() {\r\n        // update corresponding label to now focus on the new input\r\n        if (this.ids.ELEMENT) {\r\n            let label = document.querySelector(\r\n                '[for=\"' + this.ids.ELEMENT + '\"]'\r\n            );\r\n            if (label) {\r\n                label.ariaAutocompleteOriginalFor = this.ids.ELEMENT;\r\n                label.setAttribute('for', this.ids.INPUT);\r\n            }\r\n        }\r\n\r\n        // update aria-describedby and aria-labelledby attributes if present\r\n        let describedBy = this.element.getAttribute('aria-describedby');\r\n        if (describedBy) {\r\n            this.input.setAttribute('aria-describedby', describedBy);\r\n        }\r\n        let labelledBy = this.element.getAttribute('aria-labelledby');\r\n        if (labelledBy) {\r\n            this.input.setAttribute('aria-labelledby', labelledBy);\r\n        }\r\n\r\n        // if selected item(s) already exists\r\n        let disable = this.disabled;\r\n        if (this.selected.length) {\r\n            // for multi select variant, set selected items\r\n            if (this.multiple) {\r\n                this.buildMultiSelected();\r\n                disable = this.selected.length >= this.options.maxItems;\r\n            }\r\n            // for single select variant, set value to match\r\n            else {\r\n                this.input.value = this.selected[0].label || '';\r\n                this.term = this.inputPollingValue = this.input.value;\r\n            }\r\n        }\r\n\r\n        // setup input description - done here in case value is affected above\r\n        this.setInputDescription();\r\n\r\n        // disable the control if the invoked element was disabled\r\n        if (disable || !!this.element.disabled) {\r\n            this.disable();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @description build and insert component html structure\r\n     */\r\n    setHtml() {\r\n        let o = this.options;\r\n        let cssName = this.cssNameSpace;\r\n        let explainerText = o.srListLabelText;\r\n        let name = o.name ? ` ${o.name}` : ``;\r\n        let listClass = o.listClassName ? ` ${o.listClassName}` : '';\r\n        let inputClass = o.inputClassName ? ` ${o.inputClassName}` : '';\r\n        let wrapperClass = o.wrapperClassName ? ` ${o.wrapperClassName}` : '';\r\n        let explainer = explainerText ? ` aria-label=\"${explainerText}\"` : '';\r\n\r\n        let newHtml = [\r\n            `<div id=\"${this.ids.WRAPPER}\" class=\"${cssName}__wrapper${wrapperClass}\">`\r\n        ];\r\n\r\n        // add input\r\n        newHtml.push(\r\n            `<input type=\"text\" autocomplete=\"off\" aria-expanded=\"false\" aria-autocomplete=\"list\" ` +\r\n                `role=\"combobox\" id=\"${this.ids.INPUT}\" placeholder=\"${o.placeholder}\" ` +\r\n                `aria-owns=\"${this.ids.LIST}\" aria-placeholder=\"${o.placeholder}\" ` +\r\n                `class=\"${cssName}__input${inputClass}\"${name} />`\r\n        );\r\n\r\n        // button to show all available options\r\n        if (o.showAllControl) {\r\n            newHtml.push(\r\n                `<span role=\"button\" aria-label=\"${o.srShowAllText}\" class=\"${cssName}__show-all\" ` +\r\n                    `tabindex=\"0\" id=\"${this.ids.BUTTON}\" aria-expanded=\"false\"></span>`\r\n            );\r\n        }\r\n        // add the list holder\r\n        newHtml.push(\r\n            `<ul id=\"${this.ids.LIST}\" class=\"${cssName}__list${listClass}\" role=\"listbox\" ` +\r\n                `hidden=\"hidden\"${explainer}></ul>`\r\n        );\r\n        // add the screen reader assistance element\r\n        newHtml.push(\r\n            `<span class=\"sr-only ${cssName}__sr-only ${cssName}__sr-assistance\" ` +\r\n                `id=\"${this.ids.SR_ASSISTANCE}\">${o.srAssistiveText}</span>`\r\n        );\r\n        // add element for added screen reader announcements\r\n        newHtml.push(\r\n            `<span class=\"sr-only ${cssName}__sr-only ${cssName}__sr-announcements\" ` +\r\n                `id=\"${this.ids.SR_ANNOUNCEMENTS}\" aria-live=\"polite\" aria-atomic=\"true\"></span>`\r\n        );\r\n\r\n        // close all and append\r\n        newHtml.push(`</div>`);\r\n        this.element.insertAdjacentHTML('afterend', newHtml.join(''));\r\n    }\r\n\r\n    /**\r\n     * @description generate api object to expose on the element\r\n     */\r\n    generateApi() {\r\n        this.api = {\r\n            open: () => this.show.call(this),\r\n            close: () => this.hide.call(this)\r\n        };\r\n\r\n        let a = [\r\n            'options',\r\n            'refresh',\r\n            'destroy',\r\n            'filter',\r\n            'input',\r\n            'wrapper',\r\n            'list',\r\n            'selected'\r\n        ];\r\n\r\n        for (let i = 0, l = a.length; i < l; i += 1) {\r\n            this.api[a[i]] =\r\n                typeof this[a[i]] === 'function'\r\n                    ? (...args) => this[a[i]].apply(this, args)\r\n                    : this[a[i]];\r\n        }\r\n\r\n        // store api on original element\r\n        this.element.ariaAutocomplete = this.api;\r\n    }\r\n\r\n    /**\r\n     * refresh method for use after changing options, source, etc. - soft destroy\r\n     * @todo: test this!\r\n     */\r\n    refresh() {\r\n        // store element, as this is wiped in destroy method\r\n        let element = this.element;\r\n        // do not do a hard destroy\r\n        this.destroy(true);\r\n        this.init(element, this.options);\r\n    }\r\n\r\n    /**\r\n     * @description destroy component\r\n     * @param {Boolean=} isRefresh\r\n     */\r\n    destroy(isRefresh = false) {\r\n        // return original label 'for' attribute back to element id\r\n        let label = document.querySelector('[for=\"' + this.ids.INPUT + '\"]');\r\n        if (label && label.ariaAutocompleteOriginalFor) {\r\n            label.setAttribute('for', label.ariaAutocompleteOriginalFor);\r\n            delete label.ariaAutocompleteOriginalFor;\r\n        }\r\n        // remove the document click if still bound\r\n        if (this.documentClickBound) {\r\n            document.removeEventListener('click', this.documentClick);\r\n        }\r\n        // remove the whole wrapper and set all instance properties to null to clean up DOMNode references\r\n        this.element.parentNode.removeChild(this.wrapper);\r\n        let destroyCheck = prop => (isRefresh ? prop instanceof Element : true);\r\n        for (let i in this) {\r\n            if (this.hasOwnProperty(i) && destroyCheck(this[i])) {\r\n                this[i] = null;\r\n            }\r\n        }\r\n        delete this.element.ariaAutocomplete;\r\n        // re-show original element\r\n        this.show(this.element);\r\n    }\r\n\r\n    /**\r\n     * @description initialise AriaAutocomplete\r\n     * @param {Element} element\r\n     * @param {Object=} options\r\n     */\r\n    init(element, options) {\r\n        this.selected = [];\r\n        this.element = element;\r\n        this.elementIsInput = element.nodeName === 'INPUT';\r\n        this.elementIsSelect = element.nodeName === 'SELECT';\r\n        this.options = mergeObjects(DEFAULT_OPTIONS, options);\r\n\r\n        // set these internally so that the component has to be properly refreshed to change them\r\n        this.source = this.options.source;\r\n        this.multiple = this.options.multiple;\r\n        this.cssNameSpace = this.options.cssNameSpace;\r\n        this.documentClick = this.handleComponentBlur.bind(this);\r\n\r\n        // create html structure\r\n        this.setHtml();\r\n\r\n        // additional app variables\r\n        this.list = document.getElementById(this.ids.LIST);\r\n        this.input = document.getElementById(this.ids.INPUT);\r\n        this.wrapper = document.getElementById(this.ids.WRAPPER);\r\n        this.showAll = document.getElementById(this.ids.BUTTON);\r\n        this.srAnnouncements = document.getElementById(\r\n            this.ids.SR_ANNOUNCEMENTS\r\n        );\r\n\r\n        // set internal source array, from static elements if necessary\r\n        this.prepListSource();\r\n\r\n        // set any further classes on component wrapper based on options\r\n        let wrapperClass = '';\r\n        if (this.options.showAllControl) {\r\n            wrapperClass += ` ${cssName}__wrapper--show-all`;\r\n        }\r\n        if (this.options.autoGrow) {\r\n            wrapperClass += ` ${this.cssNameSpace}__wrapper--autogrow`;\r\n        }\r\n        if (this.multiple) {\r\n            wrapperClass += ` ${this.cssNameSpace}__wrapper--multiple`;\r\n        }\r\n        if (wrapperClass) {\r\n            addClass(this.wrapper, wrapperClass);\r\n        }\r\n\r\n        // hide element and list manually\r\n        this.hide(this.list); // pass in the list so that the onClose is not triggered\r\n        this.hide(this.element);\r\n\r\n        // generate api object to expose\r\n        this.generateApi();\r\n\r\n        // set starting states for input - must be after source has been defined\r\n        this.setInputStartingStates();\r\n\r\n        // bind all necessary events\r\n        this.bindEvents();\r\n\r\n        // fire onready callback\r\n        this.triggerOptionCallback('onReady', [this.wrapper]);\r\n    }\r\n}\r\n\r\n/**\r\n * @description expose specific function rather than the AriaAutocomplete class\r\n * @param {Element} elem\r\n * @param {Object} options\r\n * @returns {Object}\r\n */\r\nwindow['AriaAutocomplete'] = (elem, options) => {\r\n    return new AriaAutocomplete(elem, options).api;\r\n};\r\n\r\nexport default (elem, options) => {\r\n    return new AriaAutocomplete(elem, options).api;\r\n};\r\n"]}